<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ASCII Generator</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet"/>
<link rel="icon" type="image/svg+xml" href="logo.svg"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#000;--s1:#070707;--s2:#0e0e0e;--s3:#141414;--s4:#1a1a1a;--s5:#222;
  --border:rgba(255,255,255,.07);
  --text:#fff;--t2:#777;--t3:#333;
  --muted:#777;--muted2:#333;
  --sidebar:268px;
}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:'Inter',sans-serif;font-size:13px;-webkit-font-smoothing:antialiased;letter-spacing:-.01em;overflow:hidden}

/* ── Layout ─────────────────────────────────────────────────── */
.app{display:grid;grid-template-rows:46px 1fr;height:100vh}
.body{display:grid;grid-template-columns:var(--sidebar) 1fr;overflow:hidden}

/* ── Topbar ─────────────────────────────────────────────────── */
.topbar{
  background:var(--bg);border-bottom:1px solid var(--border);
  display:flex;align-items:center;justify-content:space-between;
  padding:0 16px;gap:12px;
}
.tb-brand{display:flex;align-items:center;gap:8px;flex-shrink:0}
.tb-logo{
  width:24px;height:24px;border-radius:5px;background:#fff;
  display:flex;align-items:center;justify-content:center;
  font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;color:#000;flex-shrink:0;
}
.tb-title{font-size:11px;font-weight:700;letter-spacing:.08em;color:var(--t2);text-transform:uppercase}
.tb-center{display:flex;align-items:center;gap:1px;background:var(--s2);border:1px solid var(--border);border-radius:22px;padding:3px}
.tb-right{display:flex;align-items:center;gap:8px;flex-shrink:0}
.tb-divider{width:1px;height:16px;background:var(--border);flex-shrink:0}

/* preset buttons */
.preset-btn{
  padding:3px 11px;border-radius:18px;font-size:11px;font-weight:500;
  cursor:pointer;border:none;background:transparent;
  color:var(--t2);transition:color .12s;font-family:inherit;white-space:nowrap;
}
.preset-btn:hover{color:var(--text)}
.preset-btn.active{background:#fff;color:#000;font-weight:600}

.upload-btn{
  display:flex;align-items:center;gap:5px;padding:5px 13px;border-radius:7px;
  background:#fff;color:#000;font-size:11px;font-weight:600;
  cursor:pointer;border:none;font-family:inherit;transition:opacity .12s;white-space:nowrap;
}
.upload-btn:hover{opacity:.78}

.export-group{display:flex;background:var(--s2);border:1px solid var(--border);border-radius:7px;overflow:hidden}
.exp-btn{
  padding:5px 10px;font-size:11px;font-weight:500;
  cursor:pointer;border:none;border-right:1px solid var(--border);background:transparent;
  color:var(--t2);transition:all .12s;font-family:inherit;
}
.exp-btn:last-child{border-right:none}
.exp-btn:hover{color:var(--text);background:var(--s3)}

.tb-status{font-size:10px;color:var(--t3);font-family:'JetBrains Mono',monospace;white-space:nowrap}

/* ── Sidebar ────────────────────────────────────────────────── */
.sidebar{
  background:var(--s1);border-right:1px solid var(--border);
  overflow-y:auto;display:flex;flex-direction:column;
}
::-webkit-scrollbar{width:3px;height:3px}
::-webkit-scrollbar-thumb{background:var(--s5);border-radius:3px}
::-webkit-scrollbar-track{background:transparent}

/* Accordion sections */
.section{border-bottom:1px solid var(--border)}
.section-hdr{
  display:flex;align-items:center;justify-content:space-between;
  padding:9px 14px;cursor:pointer;user-select:none;
  font-size:9.5px;font-weight:700;letter-spacing:.1em;
  text-transform:uppercase;color:var(--t3);transition:color .12s;
}
.section-hdr:hover{color:var(--t2)}
.section-hdr.open{color:var(--t2)}
.section-hdr .arrow{font-size:8px;transition:transform .2s;opacity:.5}
.section-hdr.open .arrow{transform:rotate(180deg)}
.section-body{padding:4px 12px 14px;display:flex;flex-direction:column;gap:12px}
.section-body.hidden{display:none}

/* Image library */
.lib-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;padding:4px 12px 14px}
.lib-grid.hidden{display:none}
.lib-thumb{
  aspect-ratio:1;border-radius:6px;overflow:hidden;cursor:pointer;
  background:var(--s3);border:1px solid var(--border);
  transition:border-color .15s,transform .15s;
  display:flex;align-items:center;justify-content:center;
}
.lib-thumb:hover{border-color:rgba(255,255,255,.3);transform:scale(1.04)}
.lib-thumb.active{border-color:#fff}
.lib-thumb img{width:100%;height:100%;object-fit:cover;display:block;pointer-events:none}

/* Library tabs */
.lib-tabs{display:flex;gap:2px;padding:6px 10px 4px}
.lib-tab{flex:1;padding:5px 8px;border-radius:5px;font-size:9.5px;font-weight:700;cursor:pointer;border:none;background:transparent;color:var(--t3);transition:color .12s,background .12s;font-family:inherit;letter-spacing:.08em;text-transform:uppercase}
.lib-tab:hover{color:var(--t2)}
.lib-tab.active{background:var(--s4);color:var(--text)}
/* Animation grid */
.lib-anim-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;padding:4px 12px 14px}
.lib-anim-grid.hidden{display:none}
.lib-anim-thumb{border-radius:6px;overflow:hidden;cursor:pointer;background:var(--s3);border:1px solid var(--border);transition:border-color .15s,transform .12s;display:flex;flex-direction:column}
.lib-anim-thumb:hover{border-color:rgba(255,255,255,.3);transform:scale(1.02)}
.lib-anim-thumb.active{border-color:#fff}
.lib-anim-thumb canvas{width:100%;aspect-ratio:1.6;display:block;background:#000}
.lib-anim-thumb span{font-size:9px;font-weight:700;color:var(--t3);padding:5px 8px;letter-spacing:.08em;text-transform:uppercase;transition:color .12s}
.lib-anim-thumb.active span,.lib-anim-thumb:hover span{color:var(--t2)}
/* Anim canvas overlay */
#animCanvas{position:absolute;inset:0;display:none;pointer-events:none}

/* Controls */
.ctrl{display:flex;flex-direction:column;gap:7px}
.ctrl-row{display:flex;align-items:center;justify-content:space-between}
.ctrl-label{font-size:11px;color:var(--t2);font-weight:400}
.ctrl-val{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--t2);font-weight:400;min-width:36px;text-align:right;}
input[type=range]{
  width:100%;height:2px;border-radius:2px;cursor:pointer;
  background:var(--s5);outline:none;border:none;-webkit-appearance:none;
}
input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;width:11px;height:11px;border-radius:50%;
  background:#fff;cursor:pointer;transition:transform .12s;
}
input[type=range]:hover::-webkit-slider-thumb{transform:scale(1.25)}
input[type=range]::-webkit-slider-runnable-track{
  height:2px;border-radius:2px;
  background:linear-gradient(to right,rgba(255,255,255,.5) var(--pct,50%),var(--s5) var(--pct,50%));
}

/* Select / Textarea */
.ctrl select,.ctrl textarea,.ctrl input[type=text]{
  background:var(--s3);border:1px solid var(--border);border-radius:6px;
  color:var(--text);font-size:11.5px;font-family:'Inter',sans-serif;
  padding:6px 10px;outline:none;width:100%;transition:border-color .12s;
  -webkit-appearance:none;
}
.ctrl select{
  cursor:pointer;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5'%3E%3Cpath d='M0 0l4 5 4-5z' fill='%23555'/%3E%3C/svg%3E");
  background-repeat:no-repeat;background-position:right 10px center;padding-right:26px;
}
.ctrl select:focus,.ctrl textarea:focus,.ctrl input[type=text]:focus{border-color:rgba(255,255,255,.18)}
.ctrl textarea{resize:vertical;min-height:50px;font-size:10.5px;line-height:1.6;font-family:'JetBrains Mono',monospace}

/* Toggle */
.toggle-row{display:flex;align-items:center;justify-content:space-between;min-height:22px}
.toggle{
  position:relative;width:30px;height:17px;border-radius:9px;
  background:var(--s5);cursor:pointer;transition:background .18s;border:none;flex-shrink:0;
}
.toggle.on{background:#fff}
.toggle::after{
  content:'';position:absolute;width:11px;height:11px;border-radius:50%;
  background:#444;top:3px;left:3px;transition:left .18s cubic-bezier(.4,0,.2,1),background .18s;
}
.toggle.on::after{left:16px;background:#000}

/* Char set grid */
.charset-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:3px}
.charset-option{
  padding:6px 4px;border-radius:5px;background:transparent;border:1px solid var(--border);
  font-family:'JetBrains Mono',monospace;font-size:9.5px;cursor:pointer;
  text-align:center;color:var(--t3);transition:all .12s;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.charset-option:hover{border-color:rgba(255,255,255,.15);color:var(--t2)}
.charset-option.active{border-color:rgba(255,255,255,.35);color:var(--text);background:rgba(255,255,255,.04)}

/* Color swatch */
.color-row{display:flex;gap:8px;align-items:center}
.color-swatch{width:26px;height:26px;border-radius:5px;border:1px solid var(--border);cursor:pointer;overflow:hidden;flex-shrink:0}
.color-swatch input[type=color]{width:200%;height:200%;margin:-25%;border:none;cursor:pointer;background:none}
.color-label{font-size:11px;color:var(--t2);flex:1}

/* Depth pills */
.depth-pills{display:flex;gap:3px}
.depth-pill{
  flex:1;padding:5px 4px;border-radius:5px;border:1px solid var(--border);
  background:transparent;font-size:10px;cursor:pointer;text-align:center;
  color:var(--t3);transition:all .12s;font-weight:600;
}
.depth-pill:hover{color:var(--t2);border-color:rgba(255,255,255,.15)}
.depth-pill.active{border-color:rgba(255,255,255,.35);color:var(--text);background:rgba(255,255,255,.04)}

/* ── Preview area ───────────────────────────────────────────── */
.preview{background:var(--bg);display:flex;flex-direction:column;overflow:hidden;position:relative;}

/* Drop zone */
.dropzone{
  flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;
  border:1px dashed rgba(255,255,255,.09);margin:16px;border-radius:12px;
  cursor:pointer;transition:all .2s;gap:10px;
}
.dropzone:hover,.dropzone.drag{border-color:rgba(255,255,255,.2);background:rgba(255,255,255,.01)}
.dropzone.hidden{display:none}
.dz-icon{font-size:28px;opacity:.1;font-family:'JetBrains Mono',monospace;letter-spacing:-2px}
.dz-title{font-size:13px;font-weight:600;color:var(--t2)}
.dz-sub{font-size:11px;color:var(--t3)}
.dz-formats{display:flex;gap:4px;margin-top:2px}
.dz-fmt{padding:2px 7px;border-radius:4px;background:var(--s3);font-size:9px;font-weight:700;color:var(--t3);font-family:'JetBrains Mono',monospace;letter-spacing:.04em}
.dz-samples{display:flex;gap:5px;margin-top:6px}
.sample-btn{
  padding:5px 12px;border-radius:6px;font-size:10.5px;font-weight:500;
  cursor:pointer;border:1px solid var(--border);background:transparent;
  color:var(--t2);transition:all .12s;font-family:inherit;
}
.sample-btn:hover{border-color:rgba(255,255,255,.18);color:var(--text)}

/* SVG Output */
.output-wrap{flex:1;overflow:hidden;display:none;flex-direction:column;position:relative;}
.output-wrap.visible{display:flex}
.svg-container{
  flex:1;overflow:auto;display:flex;align-items:center;justify-content:center;
  padding:32px;position:relative;
}
/* Always center the artboard regardless of zoom */
#svgWrapper{
  position:relative;display:inline-flex;
  align-items:center;justify-content:center;
  transform-origin:center center;
}
#asciiSvg{display:block;transform-origin:center center;cursor:grab;user-select:none;-webkit-user-select:none;}
#asciiSvg:active{cursor:grabbing}

/* Zoom bar */
.zoom-bar{
  position:absolute;bottom:12px;right:12px;
  display:flex;align-items:center;gap:4px;
  background:rgba(7,7,7,.92);border:1px solid var(--border);border-radius:8px;
  padding:4px 8px;backdrop-filter:blur(10px);
}
.zoom-btn{width:20px;height:20px;border-radius:4px;background:transparent;border:none;cursor:pointer;color:var(--t2);font-size:13px;display:flex;align-items:center;justify-content:center;transition:color .12s}
.zoom-btn:hover{color:var(--text)}
.zoom-val{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--t2);min-width:34px;text-align:center}

/* Info bar */
.info-bar{
  padding:5px 14px;border-top:1px solid var(--border);
  display:flex;align-items:center;gap:16px;flex-shrink:0;background:var(--s1);
}
.info-item{font-size:9.5px;color:var(--t3);font-family:'JetBrains Mono',monospace;display:flex;align-items:center;gap:5px}
.info-dot{width:4px;height:4px;border-radius:50%;background:var(--t3);flex-shrink:0}

/* Parallax indicator */
.parallax-badge{
  position:absolute;top:12px;left:12px;
  background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.1);
  border-radius:20px;padding:3px 10px;font-size:9.5px;font-weight:600;
  color:var(--t2);display:none;align-items:center;gap:5px;
  letter-spacing:.06em;text-transform:uppercase;backdrop-filter:blur(8px);
}
.parallax-badge.visible{display:flex}
.parallax-badge span{width:4px;height:4px;border-radius:50%;background:var(--t2);animation:pdot 1.4s ease infinite;flex-shrink:0}
@keyframes pdot{0%,100%{opacity:1}50%{opacity:.2}}

/* Processing spinner */
.processing{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);backdrop-filter:blur(6px);z-index:10;}
.processing.visible{display:flex}
.spinner{width:22px;height:22px;border-radius:50%;border:2px solid var(--s5);border-top-color:rgba(255,255,255,.5);animation:spin .7s linear infinite;}
@keyframes spin{to{transform:rotate(360deg)}}

/* Hidden inputs */
#fileInput{display:none}
#sampleCanvas{display:none}
</style>
</head>
<body>
<div class="app">

<!-- ── TOPBAR ────────────────────────────────────────────────── -->
<header class="topbar">
  <div class="tb-brand">
    <img src="logo.svg" width="26" height="26" alt="ASCII Generator" style="display:block;flex-shrink:0"/>
    <div class="tb-title">ASCII<span>.</span>GENERATOR</div>
  </div>

  <div class="tb-center">
    <button class="preset-btn active" data-preset="standard">Standard</button>
    <button class="preset-btn" data-preset="matrix">Matrix</button>
    <button class="preset-btn" data-preset="blueprint">Blueprint</button>
    <button class="preset-btn" data-preset="neon">Neon</button>
    <button class="preset-btn" data-preset="retro">Retro</button>
  </div>

  <div class="tb-right">
    <div class="tb-status" id="statusText">No image loaded</div>
    <div class="tb-divider"></div>
    <div class="export-group">
      <button class="exp-btn" id="exportSvg">SVG</button>
      <button class="exp-btn" id="exportPng">PNG</button>
      <button class="exp-btn" id="exportTxt">TXT</button>
      <button class="exp-btn" id="copySvg">Copy</button>
    </div>
    <button class="upload-btn" id="uploadBtn">↑ Upload</button>
    <input type="file" id="fileInput" accept="image/*"/>
  </div>
</header>

<div class="body">

<!-- ── SIDEBAR ──────────────────────────────────────────────── -->
<aside class="sidebar">

  <!-- IMAGE LIBRARY -->
  <div class="section">
    <div class="section-hdr open" data-section="library">
      Library <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-library" style="padding:0;gap:0">
      <div class="lib-tabs">
        <button class="lib-tab active" id="libTabImages">Images</button>
        <button class="lib-tab" id="libTabAnims">Animations</button>
      </div>
      <!-- Images panel -->
      <div class="lib-grid" id="libImgGrid">
        <div class="lib-thumb active" data-src="lib-checkered-flag.png" data-label="Checkered Flag" title="Checkered Flag">
          <img src="lib-checkered-flag.png" alt="Checkered Flag"/>
        </div>
        <div class="lib-thumb" data-src="lib-peace-glove.png" data-label="Peace Glove" title="Peace Glove">
          <img src="lib-peace-glove.png" alt="Peace Glove"/>
        </div>
        <div class="lib-thumb" data-src="lib-shaka-glove.png" data-label="Shaka Glove" title="Shaka Glove">
          <img src="lib-shaka-glove.png" alt="Shaka Glove"/>
        </div>
        <div class="lib-thumb" data-src="lib-dice.png" data-label="Dice" title="Dice">
          <img src="lib-dice.png" alt="Dice"/>
        </div>
        <div class="lib-thumb" data-src="lib-money.png" data-label="Money Roll" title="Money Roll">
          <img src="lib-money.png" alt="Money Roll"/>
        </div>
        <div class="lib-thumb" data-src="lib-chess-knight.png" data-label="Chess Knight" title="Chess Knight">
          <img src="lib-chess-knight.png" alt="Chess Knight"/>
        </div>
        <div class="lib-thumb" data-src="lib-fire-panther.png" data-label="Fire Panther" title="Fire Panther">
          <img src="lib-fire-panther.png" alt="Fire Panther"/>
        </div>
      </div>
      <!-- Animations panel -->
      <div class="lib-anim-grid hidden" id="libAnimGrid">
        <div class="lib-anim-thumb" data-anim="matrix-rain" title="Matrix Rain">
          <canvas></canvas><span>Matrix Rain</span>
        </div>
        <div class="lib-anim-thumb" data-anim="symbol-tide" title="Symbol Tide">
          <canvas></canvas><span>Symbol Tide</span>
        </div>
        <div class="lib-anim-thumb" data-anim="pulse" title="Pulse">
          <canvas></canvas><span>Pulse</span>
        </div>
        <div class="lib-anim-thumb" data-anim="drift" title="Drift">
          <canvas></canvas><span>Drift</span>
        </div>
        <div class="lib-anim-thumb" data-anim="warp" title="Warp">
          <canvas></canvas><span>Warp</span>
        </div>
        <div class="lib-anim-thumb" data-anim="noise-field" title="Noise Field">
          <canvas></canvas><span>Noise Field</span>
        </div>
      </div>
    </div>
  </div>

  <!-- CHARACTER SET -->
  <div class="section">
    <div class="section-hdr open" data-section="charset">
      Characters <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-charset">
      <div class="charset-grid" id="charsetGrid">
        <div class="charset-option active" data-charset="standard" title=" .:-=+*#%@">Dense</div>
        <div class="charset-option" data-charset="blocks" title=" ░▒▓█">Blocks</div>
        <div class="charset-option" data-charset="simple" title=" .-=+*#">Simple</div>
        <div class="charset-option" data-charset="binary" title=" 01">Binary</div>
        <div class="charset-option" data-charset="hex" title=" 0-F">Hex</div>
        <div class="charset-option" data-charset="braille" title="⠀⠁⠃⠇">Braille</div>
      </div>
      <div class="ctrl">
        <div class="ctrl-label">Custom charset</div>
        <textarea id="customCharset" placeholder="Type chars lightest→darkest&#10;e.g.:  .:-=+*#%@$" rows="2"> .:-=+*#%@$</textarea>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Size</div>
          <div class="ctrl-val" id="colsVal">120</div>
        </div>
        <input type="range" id="cols" min="20" max="300" value="120"/>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Invert characters</div>
        <button class="toggle" id="invertChars"></button>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Edge detection</div>
        <button class="toggle" id="edgeDetect"></button>
      </div>
    </div>
  </div>

  <!-- TYPOGRAPHY -->
  <div class="section">
    <div class="section-hdr open" data-section="typo">
      Typography <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-typo">
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Scale</div>
          <div class="ctrl-val" id="scaleVal">100%</div>
        </div>
        <input type="range" id="scaleSlider" min="10" max="400" value="100"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Font size</div>
          <div class="ctrl-val" id="fontSizeVal">10px</div>
        </div>
        <input type="range" id="fontSize" min="4" max="24" value="10"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Line height</div>
          <div class="ctrl-val" id="lineHeightVal">1.20</div>
        </div>
        <input type="range" id="lineHeight" min="80" max="180" value="120"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Letter spacing</div>
          <div class="ctrl-val" id="letterSpacingVal">0.0</div>
        </div>
        <input type="range" id="letterSpacing" min="-20" max="40" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-label">Font family</div>
        <select id="fontFamily">
          <option value="'JetBrains Mono',monospace">JetBrains Mono</option>
          <option value="'Courier New',monospace">Courier New</option>
          <option value="monospace">System Mono</option>
          <option value="'Lucida Console',monospace">Lucida Console</option>
        </select>
      </div>
    </div>
  </div>

  <!-- COLOR -->
  <div class="section">
    <div class="section-hdr open" data-section="color">
      Color <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-color">
      <div class="ctrl">
        <div class="ctrl-label">Mode</div>
        <select id="colorMode">
          <option value="color">Full color</option>
          <option value="mono">Monochrome</option>
          <option value="invert">Invert color</option>
          <option value="grayscale">Grayscale</option>
          <option value="sepia">Sepia</option>
          <option value="hue">Hue shift</option>
        </select>
      </div>
      <div class="color-row">
        <div class="color-swatch"><input type="color" id="bgColor" value="#000000"/></div>
        <div class="color-label">Background</div>
      </div>
      <div class="color-row" id="fgColorRow">
        <div class="color-swatch"><input type="color" id="fgColor" value="#00ff41"/></div>
        <div class="color-label">Foreground (mono)</div>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Brightness</div>
          <div class="ctrl-val" id="brightnessVal">0</div>
        </div>
        <input type="range" id="brightness" min="-100" max="100" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Contrast</div>
          <div class="ctrl-val" id="contrastVal">0</div>
        </div>
        <input type="range" id="contrast" min="-100" max="100" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Saturation</div>
          <div class="ctrl-val" id="saturationVal">100%</div>
        </div>
        <input type="range" id="saturation" min="0" max="200" value="100"/>
      </div>
      <div class="ctrl" id="hueRow" style="display:none">
        <div class="ctrl-row">
          <div class="ctrl-label">Hue shift</div>
          <div class="ctrl-val" id="hueVal">0°</div>
        </div>
        <input type="range" id="hue" min="0" max="360" value="0"/>
      </div>
    </div>
  </div>

  <!-- IMAGE PROCESSING -->
  <div class="section">
    <div class="section-hdr" data-section="img">
      Image Processing <span class="arrow">▾</span>
    </div>
    <div class="section-body hidden" id="body-img">
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Pre-blur</div>
          <div class="ctrl-val" id="blurVal">0</div>
        </div>
        <input type="range" id="blur" min="0" max="10" value="0" step="0.5"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Posterize</div>
          <div class="ctrl-val" id="posterizeVal">Off</div>
        </div>
        <input type="range" id="posterize" min="0" max="8" value="0" step="1"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Threshold</div>
          <div class="ctrl-val" id="thresholdVal">Off</div>
        </div>
        <input type="range" id="threshold" min="0" max="255" value="0"/>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Dithering (Floyd-Steinberg)</div>
        <button class="toggle" id="dithering"></button>
      </div>
    </div>
  </div>

  <!-- PARALLAX -->
  <div class="section">
    <div class="section-hdr" data-section="parallax">
      Parallax Effect <span class="arrow">▾</span>
    </div>
    <div class="section-body hidden" id="body-parallax">
      <div class="toggle-row">
        <div class="ctrl-label" style="font-weight:700">Enable parallax</div>
        <button class="toggle" id="parallaxToggle"></button>
      </div>
      <div id="parallaxControls" style="display:flex;flex-direction:column;gap:10px;opacity:.4;pointer-events:none">
        <div class="ctrl">
          <div class="ctrl-label">Depth layers</div>
          <div class="depth-pills">
            <div class="depth-pill active" data-layers="3">3</div>
            <div class="depth-pill" data-layers="5">5</div>
            <div class="depth-pill" data-layers="7">7</div>
          </div>
        </div>
        <div class="ctrl">
          <div class="ctrl-row">
            <div class="ctrl-label">Intensity</div>
            <div class="ctrl-val" id="parallaxIntVal">20px</div>
          </div>
          <input type="range" id="parallaxInt" min="5" max="80" value="20"/>
        </div>
        <div class="ctrl">
          <div class="ctrl-label">Mode</div>
          <select id="parallaxMode">
            <option value="mouse">Mouse tracking</option>
            <option value="scroll">Scroll parallax</option>
            <option value="auto">Auto animate</option>
            <option value="tilt">Device tilt</option>
          </select>
        </div>
        <div class="ctrl">
          <div class="ctrl-row">
            <div class="ctrl-label">Smoothing</div>
            <div class="ctrl-val" id="parallaxSmoothVal">0.08</div>
          </div>
          <input type="range" id="parallaxSmooth" min="1" max="20" value="8"/>
        </div>
        <div class="toggle-row">
          <div class="ctrl-label">Depth fog</div>
          <button class="toggle on" id="depthFog"></button>
        </div>
        <div class="toggle-row">
          <div class="ctrl-label">3D perspective</div>
          <button class="toggle on" id="perspective3d"></button>
        </div>
      </div>
    </div>
  </div>

</aside>

<!-- ── PREVIEW ───────────────────────────────────────────────── -->
<main class="preview">
  <div class="processing" id="processing"><div class="spinner"></div></div>

  <!-- Drop zone -->
  <div class="dropzone" id="dropzone">
    <div class="dz-icon">▓░▒</div>
    <div class="dz-title">Drop image here or click to upload</div>
    <div class="dz-sub">Converts any photo to editable vector ASCII art</div>
    <div class="dz-formats">
      <div class="dz-fmt">PNG</div><div class="dz-fmt">JPG</div>
      <div class="dz-fmt">WEBP</div><div class="dz-fmt">GIF</div>
    </div>
    <div class="dz-samples">
      <button class="sample-btn" data-sample="gradient">Try gradient</button>
      <button class="sample-btn" data-sample="portrait">Try portrait</button>
      <button class="sample-btn" data-sample="landscape">Try landscape</button>
    </div>
  </div>

  <!-- Output -->
  <div class="output-wrap" id="outputWrap">
    <div class="parallax-badge" id="parallaxBadge"><span></span>PARALLAX ACTIVE</div>
    <div class="svg-container" id="svgContainer">
      <canvas id="animCanvas"></canvas>
      <div id="svgWrapper">
        <svg id="asciiSvg" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>
    </div>
    <div class="zoom-bar">
      <button class="zoom-btn" id="zoomOut">−</button>
      <div class="zoom-val" id="zoomVal">100%</div>
      <button class="zoom-btn" id="zoomIn">+</button>
      <button class="zoom-btn" id="zoomFit" title="Fit to screen" style="font-size:10px">⊞</button>
      <button class="zoom-btn" id="resetPos" title="Reset position" style="font-size:10px">⌖</button>
    </div>
  </div>

  <!-- Info bar -->
  <div class="info-bar">
    <div class="info-item"><div class="info-dot"></div><span id="infoSize">—</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoChars">—</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoMode">color</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoFile">no file</span></div>
  </div>
</main>

</div>
</div>

<!-- Hidden canvas for image processing -->
<canvas id="processingCanvas" style="display:none"></canvas>

<script>
// ═══════════════════════════════════════════════════════════════
//  CHARACTER SETS
// ═══════════════════════════════════════════════════════════════
const CHARSETS = {
  standard: ` .'"\`^",:;Il!i><~+_-?][}{1)(|/\\tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$`,
  blocks:   ` ░▒▓█`,
  simple:   ` .-=+*#%@`,
  binary:   ` 01`,
  hex:      ` 0123456789ABCDEF`,
  braille:  ` ⠁⠃⠇⠏⠟⠿⣿`,
};

const PRESETS = {
  standard: { colorMode:'color',   bgColor:'#000000', fgColor:'#ffffff', fontSize:10, cols:120, lineHeight:120, invertChars:false, charset:'standard' },
  matrix:   { colorMode:'mono',    bgColor:'#000000', fgColor:'#00ff41', fontSize:10, cols:100, lineHeight:120, invertChars:false, charset:'simple'   },
  blueprint:{ colorMode:'mono',    bgColor:'#0a1628', fgColor:'#4f8ef7', fontSize:9,  cols:130, lineHeight:115, invertChars:false, charset:'standard'  },
  neon:     { colorMode:'hue',     bgColor:'#080010', fgColor:'#ff00ff', fontSize:11, cols:90,  lineHeight:125, invertChars:false, charset:'blocks'    },
  retro:    { colorMode:'sepia',   bgColor:'#1a0e00', fgColor:'#d4a850', fontSize:10, cols:100, lineHeight:118, invertChars:false, charset:'standard'  },
};

// ═══════════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════════
let state = {
  // image
  imageLoaded: false,
  imageEl: null,
  imgW: 0, imgH: 0,
  // char
  charset: 'standard',
  customChars: ` .:-=+*#%@$`,
  cols: 120,
  invertChars: false,
  edgeDetect: false,
  dithering: false,
  // typo
  fontSize: 10,
  lineHeight: 1.20,
  letterSpacing: 0,
  fontFamily: `'JetBrains Mono',monospace`,
  // color
  colorMode: 'color',
  bgColor: '#000000',
  fgColor: '#00ff41',
  brightness: 0,
  contrast: 0,
  saturation: 100,
  hue: 0,
  // image proc
  blur: 0,
  posterize: 0,
  threshold: 0,
  // parallax
  parallaxEnabled: false,
  parallaxLayers: 3,
  parallaxInt: 20,
  parallaxMode: 'mouse',
  parallaxSmooth: 0.08,
  depthFog: true,
  perspective3d: true,
  // ui
  zoom: 1,
};

let asciiGrid = [];         // {char, r,g,b, brightness}[][]
let parallaxX = 0, parallaxY = 0;
let targetX = 0, targetY = 0;
let rafId = null;
let autoAngleT = 0;
let renderDebounce = null;

// ═══════════════════════════════════════════════════════════════
//  DOM REFS
// ═══════════════════════════════════════════════════════════════
const dropzone    = document.getElementById('dropzone');
const outputWrap  = document.getElementById('outputWrap');
const svgEl       = document.getElementById('asciiSvg');
const svgWrapper  = document.getElementById('svgWrapper');
const svgContainer= document.getElementById('svgContainer');
const fileInput   = document.getElementById('fileInput');
const canvas      = document.getElementById('processingCanvas');
const ctx         = canvas.getContext('2d', {willReadFrequently:true});
const processing  = document.getElementById('processing');
const parallaxBadge = document.getElementById('parallaxBadge');

// ═══════════════════════════════════════════════════════════════
//  IMAGE LOADING
// ═══════════════════════════════════════════════════════════════
function loadImageFile(file) {
  const url = URL.createObjectURL(file);
  loadImageUrl(url, file.name);
}

function loadImageUrl(url, name='image') {
  if(animRaf) stopAnimation();
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    state.imageEl = img;
    state.imgW = img.naturalWidth;
    state.imgH = img.naturalHeight;
    state.imageLoaded = true;
    document.getElementById('infoFile').textContent = name;
    showOutput();
    scheduleRender();
    URL.revokeObjectURL(url);
  };
  img.src = url;
}

function generateSampleImage(type) {
  const w = 600, h = 400;
  canvas.width = w; canvas.height = h;

  if(type === 'gradient') {
    const g = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,w/1.5);
    g.addColorStop(0,'#ffffff'); g.addColorStop(.3,'#cc88ff');
    g.addColorStop(.6,'#4466ff'); g.addColorStop(1,'#000000');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    // add some circles
    for(let i=0;i<8;i++){
      const r=20+Math.random()*80, cx=Math.random()*w, cy=Math.random()*h;
      const g2=ctx.createRadialGradient(cx,cy,0,cx,cy,r);
      g2.addColorStop(0,'rgba(255,255,255,.8)'); g2.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    }
  } else if(type === 'portrait') {
    // Face-like shape
    ctx.fillStyle='#1a1a2e'; ctx.fillRect(0,0,w,h);
    // Head
    const face=ctx.createRadialGradient(w/2,h/2-20,10,w/2,h/2-20,160);
    face.addColorStop(0,'#f0d0a0'); face.addColorStop(.7,'#d4a060'); face.addColorStop(1,'#1a1a2e');
    ctx.fillStyle=face; ctx.beginPath(); ctx.ellipse(w/2,h/2-20,150,170,0,0,Math.PI*2); ctx.fill();
    // Eyes
    ctx.fillStyle='rgba(0,0,0,.8)';
    ctx.beginPath(); ctx.ellipse(w/2-50,h/2-50,18,12,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(w/2+50,h/2-50,18,12,0,0,Math.PI*2); ctx.fill();
    // Eye highlights
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.beginPath(); ctx.ellipse(w/2-43,h/2-55,5,4,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(w/2+57,h/2-55,5,4,0,0,Math.PI*2); ctx.fill();
    // Nose
    ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(w/2,h/2-30); ctx.lineTo(w/2-20,h/2+20); ctx.lineTo(w/2+20,h/2+20); ctx.stroke();
    // Mouth
    ctx.strokeStyle='rgba(180,80,80,.7)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(w/2,h/2+50,40,0.1,Math.PI-0.1); ctx.stroke();
    // Hair
    const hair=ctx.createLinearGradient(w/2-150,0,w/2+150,100);
    hair.addColorStop(0,'#1a0a00'); hair.addColorStop(1,'#4a2000');
    ctx.fillStyle=hair;
    ctx.beginPath(); ctx.ellipse(w/2,h/2-120,155,80,0,Math.PI,Math.PI*2); ctx.fill();
  } else { // landscape
    // Sky
    const sky=ctx.createLinearGradient(0,0,0,h*0.6);
    sky.addColorStop(0,'#0a0a30'); sky.addColorStop(.5,'#1a3a6a'); sky.addColorStop(1,'#2a6aa0');
    ctx.fillStyle=sky; ctx.fillRect(0,0,w,h*0.6);
    // Stars
    for(let i=0;i<80;i++){
      const x=Math.random()*w, y=Math.random()*h*0.5, r=Math.random()*1.5;
      ctx.fillStyle=`rgba(255,255,255,${0.3+Math.random()*.7})`;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    // Moon
    const moon=ctx.createRadialGradient(w*0.8,h*0.1,0,w*0.8,h*0.1,50);
    moon.addColorStop(0,'#ffffee'); moon.addColorStop(.8,'#ddddbb'); moon.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=moon; ctx.beginPath(); ctx.arc(w*0.8,h*0.1,50,0,Math.PI*2); ctx.fill();
    // Mountains
    ctx.fillStyle='#0d1f0d';
    ctx.beginPath(); ctx.moveTo(0,h*0.6);
    for(let x=0;x<=w;x+=30){
      const y=h*0.6-Math.sin(x/w*Math.PI*2)*h*0.25-Math.sin(x/w*Math.PI*5)*h*0.1;
      ctx.lineTo(x,y);
    }
    ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.fill();
    // Water reflection
    const water=ctx.createLinearGradient(0,h*0.65,0,h);
    water.addColorStop(0,'#0a2030'); water.addColorStop(1,'#050f18');
    ctx.fillStyle=water; ctx.fillRect(0,h*0.65,w,h*0.35);
    // Reflection shimmer
    for(let i=0;i<20;i++){
      const rx=Math.random()*w, ry=h*0.7+Math.random()*h*0.25;
      ctx.fillStyle=`rgba(100,150,200,${0.05+Math.random()*.15})`;
      ctx.fillRect(rx,ry,2+Math.random()*60,1);
    }
  }

  const dataUrl = canvas.toDataURL();
  const img = new Image();
  img.onload = () => {
    state.imageEl = img; state.imgW = w; state.imgH = h;
    state.imageLoaded = true;
    document.getElementById('infoFile').textContent = `sample-${type}`;
    showOutput(); scheduleRender();
  };
  img.src = dataUrl;
}

// ═══════════════════════════════════════════════════════════════
//  IMAGE PROCESSING
// ═══════════════════════════════════════════════════════════════
function getPixelData() {
  const cols = state.cols;
  const aspectCorrection = 0.45; // monospace chars are ~2:1 h:w
  const rows = Math.round(cols * (state.imgH / state.imgW) * aspectCorrection);

  canvas.width = cols; canvas.height = rows;
  ctx.clearRect(0,0,cols,rows);

  // Apply blur via CSS filter on offscreen
  ctx.filter = state.blur > 0 ? `blur(${state.blur}px)` : 'none';
  ctx.drawImage(state.imageEl, 0,0, cols, rows);
  ctx.filter = 'none';

  let data = ctx.getImageData(0,0,cols,rows);
  applyColorAdjust(data);
  if(state.posterize > 0) applyPosterize(data);
  if(state.threshold > 0) applyThreshold(data);
  if(state.edgeDetect) data = applySobel(data, cols, rows);
  if(state.dithering) applyDither(data, cols, rows);
  return {data, cols, rows};
}

function applyColorAdjust(imageData) {
  const d = imageData.data;
  const b = state.brightness / 100;
  const c = (state.contrast / 100);
  const cFactor = (259*(c*255+255)) / (255*(259-c*255));
  const sat = state.saturation / 100;
  const hDeg = state.hue;

  for(let i=0;i<d.length;i+=4) {
    let r=d[i]/255, g=d[i+1]/255, bl=d[i+2]/255;
    // brightness
    r+=b; g+=b; bl+=b;
    // contrast
    r=cFactor*(r-.5)+.5; g=cFactor*(g-.5)+.5; bl=cFactor*(bl-.5)+.5;
    // saturation
    const lum = 0.299*r+0.587*g+0.114*bl;
    r=lum+(r-lum)*sat; g=lum+(g-lum)*sat; bl=lum+(bl-lum)*sat;
    // hue shift
    if(hDeg!==0) { const [hh,ss,vv]=rgbToHsv(r,g,bl); [r,g,bl]=hsvToRgb((hh+hDeg/360)%1,ss,vv); }
    // clamp
    d[i]  =Math.max(0,Math.min(255,r*255));
    d[i+1]=Math.max(0,Math.min(255,g*255));
    d[i+2]=Math.max(0,Math.min(255,bl*255));
  }
  ctx.putImageData(imageData,0,0);
}

function applyPosterize(imageData) {
  const d=imageData.data; const levels=state.posterize;
  for(let i=0;i<d.length;i+=4){
    d[i]  =Math.round(d[i]  /255*levels)/levels*255;
    d[i+1]=Math.round(d[i+1]/255*levels)/levels*255;
    d[i+2]=Math.round(d[i+2]/255*levels)/levels*255;
  }
  ctx.putImageData(imageData,0,0);
}

function applyThreshold(imageData) {
  const d=imageData.data; const t=state.threshold;
  for(let i=0;i<d.length;i+=4){
    const lum=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    const v=lum>t?255:0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(imageData,0,0);
}

function applySobel(imageData, w, h) {
  const src=imageData.data; const out=ctx.createImageData(w,h); const od=out.data;
  const kx=[[-1,0,1],[-2,0,2],[-1,0,1]];
  const ky=[[-1,-2,-1],[0,0,0],[1,2,1]];
  for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){
    let gx=0,gy=0;
    for(let ky2=0;ky2<3;ky2++){for(let kx2=0;kx2<3;kx2++){
      const px=((y+ky2-1)*w+(x+kx2-1))*4;
      const lum=0.299*src[px]+0.587*src[px+1]+0.114*src[px+2];
      gx+=lum*kx[ky2][kx2]; gy+=lum*ky[ky2][kx2];
    }}
    const mag=Math.min(255,Math.sqrt(gx*gx+gy*gy));
    const i=(y*w+x)*4;
    od[i]=od[i+1]=od[i+2]=mag; od[i+3]=255;
  }}
  ctx.putImageData(out,0,0); return out;
}

function applyDither(imageData, w, h) {
  const d=imageData.data;
  for(let y=0;y<h;y++){for(let x=0;x<w;x++){
    const i=(y*w+x)*4;
    const old=[d[i],d[i+1],d[i+2]];
    const nw=old.map(v=>v>127?255:0);
    [d[i],d[i+1],d[i+2]]=[nw[0],nw[1],nw[2]];
    const err=old.map((v,k)=>v-nw[k]);
    const spread=[[1,0,7/16],[- 1,1,3/16],[0,1,5/16],[1,1,1/16]];
    spread.forEach(([dx,dy,f])=>{
      const nx=x+dx,ny=y+dy;
      if(nx>=0&&nx<w&&ny>=0&&ny<h){
        const ni=(ny*w+nx)*4;
        for(let c=0;c<3;c++) d[ni+c]=Math.max(0,Math.min(255,d[ni+c]+err[c]*f));
      }
    });
  }}
  ctx.putImageData(imageData,0,0);
}

// ═══════════════════════════════════════════════════════════════
//  ASCII CONVERSION
// ═══════════════════════════════════════════════════════════════
function convertToAscii() {
  const {data,cols,rows} = getPixelData();
  const d = data.data;
  const chars = state.charset==='custom'
    ? state.customChars
    : CHARSETS[state.charset] || CHARSETS.standard;

  const grid = [];
  for(let r=0;r<rows;r++){
    const row=[];
    for(let c=0;c<cols;c++){
      const i=(r*cols+c)*4;
      const rv=d[i], gv=d[i+1], bv=d[i+2];
      let lum=0.299*rv+0.587*gv+0.114*bv;

      // Apply color mode transformations for char lookup
      let charLum=lum/255;
      if(state.invertChars) charLum=1-charLum;

      const charIdx = Math.max(0,Math.min(chars.length-1,
        Math.floor(charLum*(chars.length-1))));
      const ch = chars[charIdx];

      // Color output
      let fr=rv, fg=gv, fb=bv;
      if(state.colorMode==='mono'){ const [fr2,fg2,fb2]=hexToRgb(state.fgColor); fr=fr2;fg=fg2;fb=fb2; }
      else if(state.colorMode==='grayscale'){ fr=fg=fb=lum; }
      else if(state.colorMode==='invert'){ fr=255-rv;fg=255-gv;fb=255-bv; }
      else if(state.colorMode==='sepia'){ fr=rv*.393+gv*.769+bv*.189; fg=rv*.349+gv*.686+bv*.168; fb=rv*.272+gv*.534+bv*.131; }

      // Depth layer for parallax (0 = dark background, N = bright foreground)
      const depthLayer = Math.floor(charLum * (state.parallaxLayers - 1));

      row.push({ ch, r:fr, g:fg, b:fb, lum:charLum, depth:depthLayer });
    }
    grid.push(row);
  }
  return {grid, cols, rows};
}

// ═══════════════════════════════════════════════════════════════
//  SVG RENDERING
// ═══════════════════════════════════════════════════════════════
function renderSVG({grid, cols, rows}) {
  const fs = state.fontSize;
  const lh = state.lineHeight;
  const ls = state.letterSpacing / 10; // convert from slider (tenths em)
  const fw = fs * 0.6 + ls; // approx char width
  const fh = fs * lh;
  const svgW = cols * fw;
  const svgH = rows * fh;
  const bg = state.bgColor;
  const ff = state.fontFamily;

  // Build layers
  const numLayers = state.parallaxEnabled ? state.parallaxLayers : 1;
  const layerBuffers = Array.from({length:numLayers}, ()=>[]);

  grid.forEach((row, ri) => {
    const y = ri * fh + fs; // baseline
    row.forEach((cell, ci) => {
      if(cell.ch===' ') return; // skip spaces
      const x = ci * fw;
      const color = `rgb(${Math.round(cell.r)},${Math.round(cell.g)},${Math.round(cell.b)})`;
      const layer = state.parallaxEnabled ? cell.depth : 0;

      // Depth fog: deeper layers more transparent
      let opacity = 1;
      if(state.parallaxEnabled && state.depthFog) {
        opacity = 0.3 + (cell.depth / (numLayers-1)) * 0.7;
      }

      const opacityAttr = opacity < 0.99 ? ` opacity="${opacity.toFixed(2)}"` : '';
      layerBuffers[layer].push(
        `<text x="${x.toFixed(1)}" y="${y.toFixed(1)}" fill="${color}"${opacityAttr}>${cell.ch==='&'?'&amp;':cell.ch==='<'?'&lt;':cell.ch}</text>`
      );
    });
  });

  // Build SVG
  let svgContent = `<rect width="${svgW}" height="${svgH}" fill="${bg}"/>`;

  if(state.parallaxEnabled) {
    layerBuffers.forEach((buf,i) => {
      const depthName = `layer-${i}`;
      svgContent += `<g class="plx-layer" data-layer="${i}" id="${depthName}" style="will-change:transform">${buf.join('')}</g>`;
    });
  } else {
    svgContent += `<g>${layerBuffers[0].join('')}</g>`;
  }

  const lsAttr = ls !== 0 ? ` letter-spacing="${ls.toFixed(2)}em"` : '';
  svgEl.setAttribute('viewBox',`0 0 ${svgW} ${svgH}`);
  svgEl.setAttribute('width', svgW);
  svgEl.setAttribute('height', svgH);
  svgEl.setAttribute('style',`font-family:${ff};font-size:${fs}px;background:${bg}`);
  svgEl.innerHTML = `<style>text{${lsAttr?`letter-spacing:${ls.toFixed(2)}em;`:''}dominant-baseline:auto}</style>${svgContent}`;

  // Update info
  const totalChars = grid.reduce((s,r)=>s+r.filter(c=>c.ch!==' ').length,0);
  document.getElementById('infoSize').textContent = `${cols}×${rows}`;
  document.getElementById('infoChars').textContent = `${totalChars.toLocaleString()} chars`;
  document.getElementById('infoMode').textContent = state.colorMode;
  document.getElementById('statusText').textContent = `${cols}c × ${rows}r · ${totalChars.toLocaleString()} chars`;

  // Apply zoom
  applyZoom();
  asciiGrid = grid;
}

// ═══════════════════════════════════════════════════════════════
//  PARALLAX ENGINE
// ═══════════════════════════════════════════════════════════════
function startParallax() {
  if(rafId) cancelAnimationFrame(rafId);
  parallaxX=0; parallaxY=0; targetX=0; targetY=0;
  parallaxBadge.classList.add('visible');

  const mode = state.parallaxMode;

  if(mode==='mouse') {
    svgContainer.addEventListener('mousemove', onMouseMove);
    svgContainer.addEventListener('mouseleave', onMouseLeave);
  } else if(mode==='scroll') {
    svgContainer.addEventListener('wheel', onWheel, {passive:true});
  } else if(mode==='tilt' && window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', onTilt);
  }

  animateParallax();
}

function stopParallax() {
  if(rafId) cancelAnimationFrame(rafId); rafId=null;
  svgContainer.removeEventListener('mousemove', onMouseMove);
  svgContainer.removeEventListener('mouseleave', onMouseLeave);
  svgContainer.removeEventListener('wheel', onWheel);
  window.removeEventListener('deviceorientation', onTilt);
  parallaxBadge.classList.remove('visible');
  // Reset transforms
  document.querySelectorAll('.plx-layer').forEach(l=>{ l.style.transform=''; });
  if(state.perspective3d) svgWrapper.style.transform='';
}

function onMouseMove(e) {
  const rect = svgContainer.getBoundingClientRect();
  targetX = ((e.clientX - rect.left) / rect.width  - 0.5) * 2;
  targetY = ((e.clientY - rect.top)  / rect.height - 0.5) * 2;
}
function onMouseLeave() { targetX=0; targetY=0; }
function onWheel(e) { targetY = Math.max(-1,Math.min(1, targetY + e.deltaY*0.002)); }
function onTilt(e) {
  targetX = (e.gamma||0)/45;
  targetY = ((e.beta||0)-45)/45;
}

function animateParallax() {
  const smooth = state.parallaxSmooth;
  parallaxX += (targetX - parallaxX) * smooth;
  parallaxY += (targetY - parallaxY) * smooth;

  if(state.parallaxMode==='auto') {
    autoAngleT += 0.008;
    parallaxX = Math.sin(autoAngleT)*0.6;
    parallaxY = Math.cos(autoAngleT*0.7)*0.4;
  }

  const layers = document.querySelectorAll('.plx-layer');
  const n = layers.length;
  const intensity = state.parallaxInt;

  layers.forEach((layer,i) => {
    // i=0 is darkest (background), i=n-1 is brightest (foreground)
    const t = n>1 ? (i/(n-1)) : 0;
    const depthFactor = (t - 0.5) * 2; // -1 to +1
    const dx = parallaxX * depthFactor * intensity;
    const dy = parallaxY * depthFactor * intensity;
    layer.style.transform = `translate(${dx.toFixed(2)}px,${dy.toFixed(2)}px)`;
  });

  if(state.perspective3d && n>0) {
    const rotX = parallaxY * -8;
    const rotY = parallaxX * 8;
    svgWrapper.style.transform = `perspective(800px) rotateX(${rotX.toFixed(2)}deg) rotateY(${rotY.toFixed(2)}deg)`;
    svgWrapper.style.transformStyle = 'preserve-3d';
  }

  rafId = requestAnimationFrame(animateParallax);
}

// ═══════════════════════════════════════════════════════════════
//  RENDER PIPELINE
// ═══════════════════════════════════════════════════════════════
function scheduleRender() {
  clearTimeout(renderDebounce);
  processing.classList.add('visible');
  renderDebounce = setTimeout(doRender, 80);
}

function doRender() {
  if(!state.imageLoaded) { processing.classList.remove('visible'); return; }
  try {
    const result = convertToAscii();
    renderSVG(result);
    if(state.parallaxEnabled) startParallax(); else stopParallax();
  } catch(e) { console.error(e); }
  processing.classList.remove('visible');
}

// ═══════════════════════════════════════════════════════════════
//  ZOOM
// ═══════════════════════════════════════════════════════════════
// ── Pan state ──────────────────────────────────────────────────
let panX = 0, panY = 0, isPanning = false, panStartX = 0, panStartY = 0;

function applyZoom() {
  svgWrapper.style.transform = `translate(${panX}px,${panY}px) scale(${state.zoom})`;
  svgWrapper.style.transformOrigin = 'center center';
  const pct = Math.round(state.zoom*100);
  document.getElementById('zoomVal').textContent = pct+'%';
  const slider = document.getElementById('scaleSlider');
  slider.value = Math.min(400, Math.max(10, pct));
  document.getElementById('scaleVal').textContent = pct+'%';
  updateSliderFill(slider);
}
function fitZoom() {
  const w = svgContainer.clientWidth - 64;
  const h = svgContainer.clientHeight - 64;
  const svgW = parseFloat(svgEl.getAttribute('width')||500);
  const svgH = parseFloat(svgEl.getAttribute('height')||400);
  state.zoom = Math.min(w/svgW, h/svgH, 1);
  panX = 0; panY = 0;
  applyZoom();
}
function resetPosition() {
  panX = 0; panY = 0; state.zoom = 1;
  applyZoom();
}

// Drag to pan
svgContainer.addEventListener('mousedown', e => {
  if(e.target === svgEl || svgEl.contains(e.target)) {
    isPanning = true;
    panStartX = e.clientX - panX;
    panStartY = e.clientY - panY;
    svgContainer.style.cursor = 'grabbing';
  }
});
window.addEventListener('mousemove', e => {
  if(!isPanning) return;
  panX = e.clientX - panStartX;
  panY = e.clientY - panStartY;
  applyZoom();
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  svgContainer.style.cursor = '';
});

// ═══════════════════════════════════════════════════════════════
//  EXPORT
// ═══════════════════════════════════════════════════════════════
function exportSVG() {
  const svgClone = svgEl.cloneNode(true);
  // Remove background fill rect (first direct child rect)
  const children = svgClone.children;
  for(let i=0;i<children.length;i++){
    if(children[i].tagName==='rect' && !children[i].getAttribute('class')){
      children[i].remove(); break;
    }
  }
  const s = new XMLSerializer().serializeToString(svgClone);
  const blob = new Blob([s], {type:'image/svg+xml'});
  dlBlob(blob,'ascii-art.svg');
}

function exportPNG() {
  const svgW = parseFloat(svgEl.getAttribute('width'));
  const svgH = parseFloat(svgEl.getAttribute('height'));
  const scale = 2;
  const svgClone = svgEl.cloneNode(true);
  // Remove background rect
  const children = svgClone.children;
  for(let i=0;i<children.length;i++){
    if(children[i].tagName==='rect' && !children[i].getAttribute('class')){
      children[i].remove(); break;
    }
  }
  // Strip background from SVG element's inline style
  const currentStyle = svgClone.getAttribute('style') || '';
  svgClone.setAttribute('style', currentStyle.replace(/background\s*:[^;]+;?/g, ''));
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = svgW*scale; tmpCanvas.height = svgH*scale;
  const tmpCtx = tmpCanvas.getContext('2d');
  const s = new XMLSerializer().serializeToString(svgClone);
  const blob = new Blob([s],{type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const img2 = new Image();
  img2.onload = () => {
    tmpCtx.clearRect(0,0,tmpCanvas.width,tmpCanvas.height);
    tmpCtx.drawImage(img2,0,0,svgW*scale,svgH*scale);
    tmpCanvas.toBlob(b=>{ dlBlob(b,'ascii-art.png'); URL.revokeObjectURL(url); },'image/png');
  };
  img2.src = url;
}

function exportTXT() {
  const txt = asciiGrid.map(r=>r.map(c=>c.ch).join('')).join('\n');
  dlBlob(new Blob([txt],{type:'text/plain'}),'ascii-art.txt');
}

function copySVG() {
  const s = new XMLSerializer().serializeToString(svgEl);
  navigator.clipboard.writeText(s).then(()=>{
    const btn = document.getElementById('copySvg');
    btn.textContent='✓ Copied'; setTimeout(()=>btn.textContent='⧉ Copy',1500);
  });
}

function dlBlob(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}

// ═══════════════════════════════════════════════════════════════
//  PRESETS
// ═══════════════════════════════════════════════════════════════
function applyPreset(name) {
  const p = PRESETS[name]; if(!p) return;
  Object.assign(state, {
    colorMode: p.colorMode,
    bgColor: p.bgColor,
    fgColor: p.fgColor,
    fontSize: p.fontSize,
    cols: p.cols,
    lineHeight: p.lineHeight / 100,
    invertChars: p.invertChars,
    charset: p.charset,
  });
  syncUI(); scheduleRender();
  document.getElementById('bgColor').value = p.bgColor;
  document.getElementById('fgColor').value = p.fgColor;
}

function syncUI() {
  // Sliders
  const sliders = {
    cols: state.cols,
    fontSize: state.fontSize,
    lineHeight: Math.round(state.lineHeight*100),
    letterSpacing: state.letterSpacing,
    brightness: state.brightness,
    contrast: state.contrast,
    saturation: state.saturation,
    hue: state.hue,
    blur: state.blur,
    posterize: state.posterize,
    threshold: state.threshold,
    parallaxInt: state.parallaxInt,
    parallaxSmooth: Math.round(state.parallaxSmooth*100),
  };
  Object.entries(sliders).forEach(([id,v])=>{
    const el=document.getElementById(id); if(el){el.value=v; updateSliderFill(el);}
  });
  updateAllVals();
  document.getElementById('colorMode').value = state.colorMode;
  document.getElementById('fontFamily').value = state.fontFamily;
  // charset
  document.querySelectorAll('.charset-option').forEach(el=>{
    el.classList.toggle('active', el.dataset.charset===state.charset);
  });
}

// ═══════════════════════════════════════════════════════════════
//  UI HELPERS
// ═══════════════════════════════════════════════════════════════
function showOutput() {
  dropzone.classList.add('hidden');
  outputWrap.classList.add('visible');
}

function updateAllVals() {
  const set = (id,v)=>{ const el=document.getElementById(id); if(el) el.textContent=v; };
  set('colsVal',       state.cols);
  set('fontSizeVal',   state.fontSize+'px');
  set('lineHeightVal', state.lineHeight.toFixed(2));
  set('letterSpacingVal', (state.letterSpacing/10).toFixed(1));
  set('brightnessVal', (state.brightness>0?'+':'')+state.brightness);
  set('contrastVal',   (state.contrast>0?'+':'')+state.contrast);
  set('saturationVal', state.saturation+'%');
  set('hueVal',        state.hue+'°');
  set('blurVal',       state.blur||'Off');
  set('posterizeVal',  state.posterize||'Off');
  set('thresholdVal',  state.threshold||'Off');
  set('parallaxIntVal',state.parallaxInt+'px');
  set('parallaxSmoothVal',(state.parallaxSmooth).toFixed(2));
}

function updateSliderFill(el) {
  const min=+el.min, max=+el.max, val=+el.value;
  const pct = ((val-min)/(max-min)*100).toFixed(1)+'%';
  el.style.setProperty('--pct', pct);
}

function toggleEl(id) {
  const btn = document.getElementById(id);
  btn.classList.toggle('on');
  return btn.classList.contains('on');
}

function hexToRgb(hex) {
  const r=parseInt(hex.slice(1,3),16);
  const g=parseInt(hex.slice(3,5),16);
  const b=parseInt(hex.slice(5,7),16);
  return [r,g,b];
}
function rgbToHsv(r,g,b){
  const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min;
  let h=0;
  if(d){if(max===r)h=(g-b)/d%6;else if(max===g)h=(b-r)/d+2;else h=(r-g)/d+4; h/=6; if(h<0)h+=1;}
  return [h, max?d/max:0, max];
}
function hsvToRgb(h,s,v){
  const i=Math.floor(h*6),f=h*6-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s);
  const m=i%6;
  if(m===0)return[v,t,p];if(m===1)return[q,v,p];if(m===2)return[p,v,t];
  if(m===3)return[p,q,v];if(m===4)return[t,p,v];return[v,p,q];
}

// ═══════════════════════════════════════════════════════════════
//  EVENT WIRING
// ═══════════════════════════════════════════════════════════════

// Upload
document.getElementById('uploadBtn').addEventListener('click',()=>fileInput.click());
fileInput.addEventListener('change',e=>{ if(e.target.files[0]) loadImageFile(e.target.files[0]); });

// Drop zone
dropzone.addEventListener('click',()=>fileInput.click());
document.body.addEventListener('dragover',e=>{e.preventDefault();dropzone.classList.add('drag')});
document.body.addEventListener('dragleave',()=>dropzone.classList.remove('drag'));
document.body.addEventListener('drop',e=>{
  e.preventDefault(); dropzone.classList.remove('drag');
  if(e.dataTransfer.files[0]) loadImageFile(e.dataTransfer.files[0]);
});

// Sample buttons
document.querySelectorAll('.sample-btn').forEach(btn=>{
  btn.addEventListener('click',()=>generateSampleImage(btn.dataset.sample));
});

// Presets
document.querySelectorAll('.preset-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.preset-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    applyPreset(btn.dataset.preset);
  });
});

// Charset
document.querySelectorAll('.charset-option').forEach(opt=>{
  opt.addEventListener('click',()=>{
    document.querySelectorAll('.charset-option').forEach(o=>o.classList.remove('active'));
    opt.classList.add('active');
    state.charset = opt.dataset.charset;
    scheduleRender();
  });
});
document.getElementById('customCharset').addEventListener('input',e=>{
  state.customChars = e.target.value || ' .:#@';
  state.charset = 'custom';
  document.querySelectorAll('.charset-option').forEach(o=>o.classList.remove('active'));
  scheduleRender();
});

// Sliders
function wireSlider(id, stateKey, transform, displayFn) {
  const el = document.getElementById(id);
  el.addEventListener('input',()=>{
    updateSliderFill(el);
    state[stateKey] = transform ? transform(+el.value) : +el.value;
    updateAllVals();
    scheduleRender();
  });
  updateSliderFill(el);
}
wireSlider('cols',          'cols',          null);
wireSlider('fontSize',      'fontSize',      null);
wireSlider('lineHeight',    'lineHeight',    v=>v/100);
wireSlider('letterSpacing', 'letterSpacing', null);
wireSlider('brightness',    'brightness',    null);
wireSlider('contrast',      'contrast',      null);
wireSlider('saturation',    'saturation',    null);
wireSlider('hue',           'hue',           null);
wireSlider('blur',          'blur',          null);
wireSlider('posterize',     'posterize',     null);
wireSlider('threshold',     'threshold',     null);
wireSlider('parallaxInt',   'parallaxInt',   null);
wireSlider('parallaxSmooth','parallaxSmooth',v=>v/100);

// Selects
document.getElementById('colorMode').addEventListener('change',e=>{
  state.colorMode=e.target.value;
  document.getElementById('hueRow').style.display=e.target.value==='hue'?'flex':'none';
  scheduleRender();
});
document.getElementById('fontFamily').addEventListener('change',e=>{ state.fontFamily=e.target.value; scheduleRender(); });

// Color pickers
document.getElementById('bgColor').addEventListener('input',e=>{ state.bgColor=e.target.value; scheduleRender(); });
document.getElementById('fgColor').addEventListener('input',e=>{ state.fgColor=e.target.value; scheduleRender(); });

// Toggles
document.getElementById('invertChars').addEventListener('click',()=>{ state.invertChars=toggleEl('invertChars'); scheduleRender(); });
document.getElementById('edgeDetect').addEventListener('click',()=>{ state.edgeDetect=toggleEl('edgeDetect'); scheduleRender(); });
document.getElementById('dithering').addEventListener('click',()=>{ state.dithering=toggleEl('dithering'); scheduleRender(); });
document.getElementById('depthFog').addEventListener('click',()=>{ state.depthFog=toggleEl('depthFog'); scheduleRender(); });
document.getElementById('perspective3d').addEventListener('click',()=>{ state.perspective3d=toggleEl('perspective3d'); });

// Parallax toggle
document.getElementById('parallaxToggle').addEventListener('click',()=>{
  state.parallaxEnabled=toggleEl('parallaxToggle');
  const ctrl=document.getElementById('parallaxControls');
  ctrl.style.opacity=state.parallaxEnabled?'1':'0.4';
  ctrl.style.pointerEvents=state.parallaxEnabled?'auto':'none';
  scheduleRender();
});
document.getElementById('parallaxMode').addEventListener('change',e=>{ state.parallaxMode=e.target.value; if(state.parallaxEnabled&&state.imageLoaded){stopParallax();startParallax();} });

// Depth pills
document.querySelectorAll('.depth-pill').forEach(pill=>{
  pill.addEventListener('click',()=>{
    document.querySelectorAll('.depth-pill').forEach(p=>p.classList.remove('active'));
    pill.classList.add('active');
    state.parallaxLayers=parseInt(pill.dataset.layers);
    scheduleRender();
  });
});

// Zoom
document.getElementById('zoomIn').addEventListener('click',()=>{ state.zoom=Math.min(4,state.zoom+0.1); applyZoom(); });
document.getElementById('zoomOut').addEventListener('click',()=>{ state.zoom=Math.max(0.1,state.zoom-0.1); applyZoom(); });
document.getElementById('zoomFit').addEventListener('click',fitZoom);
document.getElementById('resetPos').addEventListener('click',resetPosition);

// Scale slider (synced with zoom)
document.getElementById('scaleSlider').addEventListener('input',e=>{
  state.zoom = +e.target.value / 100;
  updateSliderFill(e.target);
  applyZoom();
});

// Mouse wheel zoom in preview
svgContainer.addEventListener('wheel',e=>{
  if(!e.ctrlKey) return;
  e.preventDefault();
  state.zoom = Math.max(0.1,Math.min(4, state.zoom - e.deltaY*0.001));
  applyZoom();
},{passive:false});

// Export
document.getElementById('exportSvg').addEventListener('click',exportSVG);
document.getElementById('exportPng').addEventListener('click',exportPNG);
document.getElementById('exportTxt').addEventListener('click',exportTXT);
document.getElementById('copySvg').addEventListener('click',copySVG);

// ═══════════════════════════════════════════════════════════════
//  ANIMATION LIBRARY
// ═══════════════════════════════════════════════════════════════
const animCanvas = document.getElementById('animCanvas');
const animCtx    = animCanvas.getContext('2d');
let animRaf = null, animKey = null, animStateObj = null, animPrevT = 0;

const ANIMATIONS = {

  /* ── 1. MATRIX RAIN ─────────────────────────────────────────── */
  'matrix-rain': {
    label:'Matrix Rain',
    createState(w,h){
      const sz=15, cols=Math.ceil(w/sz);
      const chars='@#$%&*+-/<>|?!~{}[];:=\\^÷×±';
      return { sz,w,h,chars,
        drops: Array.from({length:cols},(_,i)=>({
          col:i, y:-(Math.random()*40),
          speed: 0.06+Math.random()*0.28,
          trail:[], len:10+Math.floor(Math.random()*20),
          surge: Math.random()<0.08  // occasional bright column
        }))
      };
    },
    drawFrame(ctx,s,dt){
      const {sz,drops,chars,w,h}=s; const sc=dt/16;
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='top';
      for(const d of drops){
        d.y+=d.speed*sc;
        d.trail.unshift(chars[Math.floor(Math.random()*chars.length)]);
        if(d.trail.length>d.len) d.trail.pop();
        if(d.y-d.len>h/sz && Math.random()>0.985){
          d.y=-(5+Math.random()*30); d.trail=[];
          d.surge=Math.random()<0.08;
        }
        const x=d.col*sz;
        for(let i=0;i<d.trail.length;i++){
          const yy=(d.y-i)*sz; if(yy<-sz||yy>h) continue;
          const frac=1-i/d.len;
          if(i===0){
            // glowing head
            ctx.shadowBlur=d.surge?18:10;
            ctx.shadowColor='rgba(255,255,255,0.95)';
            ctx.font=`bold ${sz+1}px 'Courier New',monospace`;
            ctx.fillStyle='#fff';
          } else {
            ctx.shadowBlur=0;
            ctx.font=`${sz}px 'Courier New',monospace`;
            const br=Math.round((d.surge?220:160)*frac*frac);
            const a=(frac*frac*0.9).toFixed(2);
            ctx.fillStyle=`rgba(${br},${br},${br},${a})`;
          }
          ctx.fillText(d.trail[i],x,yy);
        }
        ctx.shadowBlur=0;
      }
    }
  },

  /* ── 2. SYMBOL TIDE ─────────────────────────────────────────── */
  'symbol-tide': {
    label:'Symbol Tide',
    createState(w,h){
      const sz=13, chars='@#?+×!*=&%$~^÷±∑∏√∫∂∇';
      const cols=Math.ceil(w/sz), rows=Math.ceil(h/sz);
      return { sz,w,h,chars,
        grid: Array.from({length:rows},()=>
          Array.from({length:cols},()=>({
            char:chars[Math.floor(Math.random()*chars.length)],
            alpha:Math.random()*0.3,
            base:0.04+Math.random()*0.25,
            speed:0.006+Math.random()*0.014,
            changeAt:Math.random()*3000
          }))
        )
      };
    },
    drawFrame(ctx,s,dt,t){
      const {sz,grid,chars,w,h}=s;
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='top';
      // two diagonal waves + one horizontal
      const w1x=((t*0.00018)%2-0.5)*w;
      const w2x=((t*0.00013+0.7)%2-0.5)*w;
      const w2y=((t*0.00009)%2-0.5)*h;
      for(let r=0;r<grid.length;r++) for(let c=0;c<grid[r].length;c++){
        const cell=grid[r][c];
        // lerp toward base
        cell.alpha+=(cell.base-cell.alpha)*cell.speed*(dt/16);
        if(t>cell.changeAt){
          cell.base=0.03+Math.random()*0.3;
          cell.changeAt=t+200+Math.random()*3000;
          if(Math.random()>0.5) cell.char=chars[Math.floor(Math.random()*chars.length)];
        }
        const px=c*sz, py=r*sz;
        // wave boosts
        const d1=px-w1x, d2=px-w2x+py-w2y;
        const b1=Math.max(0,1-(d1*d1)/(w*w*0.018))*0.75;
        const b2=Math.max(0,1-(d2*d2)/(w*w*0.03))*0.45;
        const a=Math.min(1,cell.alpha+b1+b2);
        if(a<0.025) continue;
        if(a>0.82){
          ctx.shadowBlur=8; ctx.shadowColor='rgba(255,255,255,0.7)';
          ctx.font=`bold ${sz+1}px 'Courier New',monospace`;
        } else {
          ctx.shadowBlur=0;
          ctx.font=`${sz-1}px 'Courier New',monospace`;
        }
        ctx.fillStyle=`rgba(255,255,255,${a.toFixed(2)})`;
        ctx.fillText(cell.char,px,py);
      }
      ctx.shadowBlur=0;
    }
  },

  /* ── 3. PULSE ────────────────────────────────────────────────── */
  'pulse': {
    label:'Pulse',
    createState(w,h){
      return {w,h,
        chars:'·+×✦●○◇◆▲△▽▼',
        rings:[], lastRing:0,
        // seed a few rings already in-progress
        init:false
      };
    },
    drawFrame(ctx,s,dt,t){
      const {w,h,rings,chars}=s;
      const cx=w/2, cy=h/2, maxR=Math.hypot(cx,cy)+30;
      // seed initial rings
      if(!s.init){ s.init=true; for(let i=0;i<5;i++) rings.push({r:maxR*i/5+5,speed:1.1+Math.random()*0.9,phase:Math.random()*Math.PI*2}); }
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='middle'; ctx.textAlign='center';
      // spawn new rings
      if(t-s.lastRing>800){ s.lastRing=t; rings.push({r:5,speed:1.1+Math.random()*0.9,phase:Math.random()*Math.PI*2}); }
      for(let i=rings.length-1;i>=0;i--){
        const ring=rings[i];
        ring.r+=ring.speed*(dt/16);
        if(ring.r>maxR){ rings.splice(i,1); continue; }
        const prog=ring.r/maxR, alpha=Math.pow(1-prog,1.4);
        if(alpha<0.01){ rings.splice(i,1); continue; }
        const numChars=Math.max(6,Math.floor(2*Math.PI*ring.r/16));
        const sz=(7+alpha*11).toFixed(0);
        ctx.font=`${sz}px 'Courier New',monospace`;
        if(alpha>0.65){ ctx.shadowBlur=12; ctx.shadowColor='rgba(255,255,255,0.8)'; }
        else { ctx.shadowBlur=0; }
        for(let j=0;j<numChars;j++){
          const angle=(j/numChars)*Math.PI*2+ring.phase+ring.r*0.004;
          const x=cx+Math.cos(angle)*ring.r, y=cy+Math.sin(angle)*ring.r;
          ctx.fillStyle=`rgba(255,255,255,${(alpha*0.95).toFixed(2)})`;
          ctx.fillText(chars[(j+Math.floor(ring.r*0.1))%chars.length],x,y);
        }
      }
      ctx.shadowBlur=0; ctx.textAlign='left';
    }
  },

  /* ── 4. DRIFT ────────────────────────────────────────────────── */
  'drift': {
    label:'Drift',
    createState(w,h){
      const chars='@#$+*=?!~^<>|&%÷×±∑';
      return { w,h,chars, t:0,
        particles: Array.from({length:90},(_,i)=>({
          x:Math.random()*w, y:Math.random()*h,
          vx:(Math.random()-.5)*0.6, vy:(Math.random()-.5)*0.6,
          ox:Math.random()*w, oy:Math.random()*h,  // orbit origin
          orbitR:20+Math.random()*60, orbitSpeed:(Math.random()-.5)*0.015,
          orbitAngle:Math.random()*Math.PI*2,
          char:chars[Math.floor(Math.random()*chars.length)],
          alpha:0.3+Math.random()*0.65,
          sz:9+Math.floor(Math.random()*13),
          pulse:Math.random()*Math.PI*2, pulseSpeed:0.02+Math.random()*0.04
        }))
      };
    },
    drawFrame(ctx,s,dt){
      const {particles,w,h}=s; const sc=dt/16; s.t+=sc;
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='middle'; ctx.textAlign='center';
      // draw connections first with additive blend
      ctx.globalCompositeOperation='lighter';
      ctx.lineWidth=0.7;
      for(let i=0;i<particles.length;i++) for(let j=i+1;j<particles.length;j++){
        const dx=particles[i].x-particles[j].x, dy=particles[i].y-particles[j].y;
        const d=Math.sqrt(dx*dx+dy*dy);
        if(d<100){
          const a=(0.08*(1-d/100)).toFixed(3);
          ctx.strokeStyle=`rgba(255,255,255,${a})`;
          ctx.beginPath(); ctx.moveTo(particles[i].x,particles[i].y);
          ctx.lineTo(particles[j].x,particles[j].y); ctx.stroke();
        }
      }
      ctx.globalCompositeOperation='source-over';
      // draw particles
      for(const p of particles){
        p.orbitAngle+=p.orbitSpeed*sc;
        p.x=((p.ox+Math.cos(p.orbitAngle)*p.orbitR)+p.vx*s.t*0.3+w*3)%w;
        p.y=((p.oy+Math.sin(p.orbitAngle)*p.orbitR)+p.vy*s.t*0.3+h*3)%h;
        p.pulse+=p.pulseSpeed*sc;
        const a=p.alpha*(0.6+0.4*Math.sin(p.pulse));
        const bright=a>0.7;
        if(bright){ ctx.shadowBlur=8; ctx.shadowColor='rgba(255,255,255,0.6)'; }
        ctx.font=`${p.sz}px 'Courier New',monospace`;
        ctx.fillStyle=`rgba(255,255,255,${a.toFixed(2)})`;
        ctx.fillText(p.char,p.x,p.y);
        if(bright) ctx.shadowBlur=0;
      }
      ctx.textAlign='left';
    }
  },

  /* ── 5. WARP ─────────────────────────────────────────────────── */
  'warp': {
    label:'Warp',
    createState(w,h){
      const chars='@#$*+·×÷±!?<>~-=';
      const make=(layer)=>({
        angle:Math.random()*Math.PI*2,
        r:Math.random()*Math.min(w,h)*(0.1+layer*0.15),
        speed:(0.4+Math.random()*1.2)*(1+layer*1.2),
        char:chars[Math.floor(Math.random()*chars.length)],
        layer
      });
      return { w,h,chars,
        stars:[
          ...Array.from({length:80},()=>make(0)),   // slow/bg
          ...Array.from({length:80},()=>make(1)),   // mid
          ...Array.from({length:60},()=>make(2))    // fast/fg
        ]
      };
    },
    drawFrame(ctx,s,dt){
      const {w,h,stars,chars}=s;
      const cx=w/2, cy=h/2, maxR=Math.hypot(cx,cy)+20, sc=dt/16;
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='middle'; ctx.textAlign='center';
      // faint center glow
      ctx.shadowBlur=0;
      for(const st of stars){
        const accel=1+Math.pow(st.r/maxR,2)*3;  // accelerate toward edge
        st.r+=st.speed*accel*sc;
        if(st.r>maxR){
          st.r=1+Math.random()*10*(st.layer+1);
          st.angle=Math.random()*Math.PI*2;
          st.char=chars[Math.floor(Math.random()*chars.length)];
        }
        const prog=st.r/maxR;
        const x=cx+Math.cos(st.angle)*st.r, y=cy+Math.sin(st.angle)*st.r;
        const sz=(6+prog*12+st.layer*2).toFixed(0);
        const alpha=Math.min(1,prog*1.4*(0.4+st.layer*0.3));
        if(alpha<0.04) continue;
        if(prog>0.75 && st.layer===2){
          ctx.shadowBlur=10; ctx.shadowColor='rgba(255,255,255,0.8)';
          ctx.font=`bold ${sz}px 'Courier New',monospace`;
        } else {
          ctx.shadowBlur=0;
          ctx.font=`${sz}px 'Courier New',monospace`;
        }
        ctx.fillStyle=`rgba(255,255,255,${alpha.toFixed(2)})`;
        ctx.fillText(st.char,x,y);
      }
      ctx.shadowBlur=0; ctx.textAlign='left';
    }
  },

  /* ── 6. NOISE FIELD ─────────────────────────────────────────── */
  'noise-field': {
    label:'Noise Field',
    createState(w,h){
      const sz=14;
      const chars=[' ','.',':','-','=','+','*','#','%','@'];
      return { sz,w,h,chars, cols:Math.ceil(w/sz), rows:Math.ceil(h/sz), t:0 };
    },
    drawFrame(ctx,s,dt){
      const {sz,chars,cols,rows,w,h}=s;
      s.t+=dt*0.00055;
      const T=s.t;
      ctx.clearRect(0,0,w,h);
      ctx.textBaseline='top';
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const nx=c/cols, ny=r/rows;
        // multi-octave smooth noise
        const v=(
          Math.sin(nx*5.1+T)*Math.cos(ny*3.7-T*0.8)*0.5+
          Math.sin(nx*10.3-T*1.3)*Math.cos(ny*8.1+T*0.6)*0.25+
          Math.sin((nx+ny)*7.2+T*0.9)*0.15+
          Math.cos(nx*2.4-ny*4.8+T*0.4)*0.1
          +0.5);
        const clamped=Math.max(0,Math.min(1,v));
        const idx=Math.floor(clamped*(chars.length-1));
        if(idx<1) continue;
        const alpha=0.1+clamped*0.85;
        // ridge highlight
        const ridge=clamped>0.78;
        if(ridge){ ctx.shadowBlur=7; ctx.shadowColor='rgba(255,255,255,0.7)'; ctx.font=`bold ${sz}px 'Courier New',monospace`; }
        else { ctx.shadowBlur=0; ctx.font=`${sz}px 'Courier New',monospace`; }
        ctx.fillStyle=`rgba(255,255,255,${alpha.toFixed(2)})`;
        ctx.fillText(chars[idx],c*sz,r*sz);
      }
      ctx.shadowBlur=0;
    }
  }

};

function startAnimation(key){
  stopAnimation();
  animKey=key;
  const anim=ANIMATIONS[key];
  const W=svgContainer.clientWidth, H=svgContainer.clientHeight;
  animCanvas.width=W; animCanvas.height=H;
  animStateObj=anim.createState(W,H);
  svgWrapper.style.display='none';
  animCanvas.style.display='block';
  document.getElementById('outputWrap').classList.add('visible');
  document.getElementById('statusText').textContent=anim.label+' — Animation';
  animPrevT=0;
  function loop(t){
    const dt=animPrevT?Math.min(t-animPrevT,100):16; animPrevT=t;
    anim.drawFrame(animCtx,animStateObj,dt,t);
    animRaf=requestAnimationFrame(loop);
  }
  animRaf=requestAnimationFrame(loop);
}

function stopAnimation(){
  if(animRaf){cancelAnimationFrame(animRaf);animRaf=null;}
  animKey=null; animStateObj=null;
  animCanvas.style.display='none';
  svgWrapper.style.display='';
}

// Draw static preview frames for each animation thumbnail
function initAnimPreviews(){
  document.querySelectorAll('.lib-anim-thumb').forEach(thumb=>{
    const key=thumb.dataset.anim, anim=ANIMATIONS[key];
    if(!anim) return;
    const pc=thumb.querySelector('canvas');
    // use rendered size
    const pw=pc.offsetWidth||140, ph=Math.round(pw/1.6)||88;
    pc.width=pw; pc.height=ph;
    const pctx=pc.getContext('2d');
    const ps=anim.createState(pw,ph);
    // warm up with fake frames
    const frames=key==='matrix-rain'?120:key==='pulse'?80:key==='warp'?100:60;
    for(let i=0;i<frames;i++) anim.drawFrame(pctx,ps,16,i*16);
  });
}

// Library tabs
document.getElementById('libTabImages').addEventListener('click',()=>{
  document.getElementById('libTabImages').classList.add('active');
  document.getElementById('libTabAnims').classList.remove('active');
  document.getElementById('libImgGrid').classList.remove('hidden');
  document.getElementById('libAnimGrid').classList.add('hidden');
});
document.getElementById('libTabAnims').addEventListener('click',()=>{
  document.getElementById('libTabAnims').classList.add('active');
  document.getElementById('libTabImages').classList.remove('active');
  document.getElementById('libAnimGrid').classList.remove('hidden');
  document.getElementById('libImgGrid').classList.add('hidden');
  initAnimPreviews();
});

// Animation thumbnail clicks
document.querySelectorAll('.lib-anim-thumb').forEach(thumb=>{
  thumb.addEventListener('click',()=>{
    document.querySelectorAll('.lib-anim-thumb').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.lib-thumb').forEach(t=>t.classList.remove('active'));
    thumb.classList.add('active');
    startAnimation(thumb.dataset.anim);
  });
});

// Image library
document.querySelectorAll('.lib-thumb').forEach(thumb=>{
  thumb.addEventListener('click',()=>{
    document.querySelectorAll('.lib-thumb').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.lib-anim-thumb').forEach(t=>t.classList.remove('active'));
    thumb.classList.add('active');
    stopAnimation();
    loadImageUrl(thumb.dataset.src, thumb.dataset.label);
  });
});

// Accordion sections
document.querySelectorAll('.section-hdr').forEach(hdr=>{
  hdr.addEventListener('click',()=>{
    const body=document.getElementById('body-'+hdr.dataset.section);
    hdr.classList.toggle('open');
    body.classList.toggle('hidden');
  });
});

// ═══════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════
// Init all slider fills
document.querySelectorAll('input[type=range]').forEach(updateSliderFill);
updateSliderFill(document.getElementById('scaleSlider'));
updateAllVals();

// Auto-load default image on start
setTimeout(()=>loadImageUrl('default.png','checkered-flag'), 200);
</script>
</body>
</html>
