<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ASCII Generator</title>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=optional" rel="stylesheet"/>
<link rel="icon" type="image/svg+xml" href="logo.svg"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#000;--s1:#070707;--s2:#0e0e0e;--s3:#141414;--s4:#1a1a1a;--s5:#222;
  --border:rgba(255,255,255,.07);
  --text:#fff;--t2:#777;--t3:#333;
  --muted:#777;--muted2:#333;
  --sidebar:268px;
}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:'Inter',sans-serif;font-size:13px;-webkit-font-smoothing:antialiased;letter-spacing:-.01em;overflow:hidden}

/* ── Layout ─────────────────────────────────────────────────── */
.app{display:grid;grid-template-rows:46px 1fr;height:100vh}
.body{display:grid;grid-template-columns:var(--sidebar) 1fr;overflow:hidden}

/* ── Topbar ─────────────────────────────────────────────────── */
.topbar{
  background:var(--bg);border-bottom:1px solid var(--border);
  display:flex;align-items:center;justify-content:space-between;
  padding:0 16px;gap:12px;
}
.tb-brand{display:flex;align-items:center;gap:8px;flex-shrink:0}
.tb-logo{
  width:24px;height:24px;border-radius:5px;background:#fff;
  display:flex;align-items:center;justify-content:center;
  font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;color:#000;flex-shrink:0;
}
.tb-title{font-size:11px;font-weight:700;letter-spacing:.08em;color:var(--t2);text-transform:uppercase}
.tb-center{display:flex;align-items:center;gap:1px;background:var(--s2);border:1px solid var(--border);border-radius:22px;padding:3px}
.tb-right{display:flex;align-items:center;gap:8px;flex-shrink:0}
.tb-divider{width:1px;height:16px;background:var(--border);flex-shrink:0}

/* preset buttons */
.preset-btn{
  padding:3px 11px;border-radius:18px;font-size:11px;font-weight:500;
  cursor:pointer;border:none;background:transparent;
  color:var(--t2);transition:color .12s;font-family:inherit;white-space:nowrap;
}
.preset-btn:hover{color:var(--text)}
.preset-btn.active{background:#fff;color:#000;font-weight:600}

.upload-btn{
  display:flex;align-items:center;gap:5px;padding:5px 13px;border-radius:7px;
  background:#fff;color:#000;font-size:11px;font-weight:600;
  cursor:pointer;border:none;font-family:inherit;transition:opacity .12s;white-space:nowrap;
}
.upload-btn:hover{opacity:.78}

.export-group{display:flex;background:var(--s2);border:1px solid var(--border);border-radius:7px;overflow:hidden}
.exp-btn{
  padding:5px 10px;font-size:11px;font-weight:500;
  cursor:pointer;border:none;border-right:1px solid var(--border);background:transparent;
  color:var(--t2);transition:all .12s;font-family:inherit;
}
.exp-btn:last-child{border-right:none}
.exp-btn:hover{color:var(--text);background:var(--s3)}

.tb-status{font-size:10px;color:var(--t3);font-family:'JetBrains Mono',monospace;white-space:nowrap}

/* ── Sidebar ────────────────────────────────────────────────── */
.sidebar{
  background:var(--s1);border-right:1px solid var(--border);
  overflow-y:auto;display:flex;flex-direction:column;
}
::-webkit-scrollbar{width:3px;height:3px}
::-webkit-scrollbar-thumb{background:var(--s5);border-radius:3px}
::-webkit-scrollbar-track{background:transparent}

/* Accordion sections */
.section{border-bottom:1px solid var(--border)}
.section-hdr{
  display:flex;align-items:center;justify-content:space-between;
  padding:9px 14px;cursor:pointer;user-select:none;
  font-size:9.5px;font-weight:700;letter-spacing:.1em;
  text-transform:uppercase;color:var(--t3);transition:color .12s;
}
.section-hdr:hover{color:var(--t2)}
.section-hdr.open{color:var(--t2)}
.section-hdr .arrow{font-size:8px;transition:transform .2s;opacity:.5}
.section-hdr.open .arrow{transform:rotate(180deg)}
.section-body{padding:4px 12px 14px;display:flex;flex-direction:column;gap:12px}
.section-body.hidden{display:none}

/* Image library */
.lib-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;padding:4px 12px 14px}
.lib-grid.hidden{display:none}
.lib-thumb{
  aspect-ratio:1;border-radius:6px;overflow:hidden;cursor:pointer;
  background:var(--s3);border:1px solid var(--border);
  transition:border-color .15s,transform .15s;
  display:flex;align-items:center;justify-content:center;
}
.lib-thumb:hover{border-color:rgba(255,255,255,.3);transform:scale(1.04)}
.lib-thumb.active{border-color:#fff}
.lib-thumb img{width:100%;height:100%;object-fit:cover;display:block;pointer-events:none}

/* Library tabs */
.lib-tabs{display:flex;gap:2px;padding:6px 10px 4px}
.lib-tab{flex:1;padding:5px 8px;border-radius:5px;font-size:9.5px;font-weight:700;cursor:pointer;border:none;background:transparent;color:var(--t3);transition:color .12s,background .12s;font-family:inherit;letter-spacing:.08em;text-transform:uppercase}
.lib-tab:hover{color:var(--t2)}
.lib-tab.active{background:var(--s4);color:var(--text)}
/* Animation grid */
.lib-anim-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;padding:4px 12px 14px}
.lib-anim-grid.hidden{display:none}
.lib-anim-thumb{border-radius:6px;overflow:hidden;cursor:pointer;background:var(--s3);border:1px solid var(--border);transition:border-color .15s,transform .12s;display:flex;flex-direction:column}
.lib-anim-thumb:hover{border-color:rgba(255,255,255,.3);transform:scale(1.02)}
.lib-anim-thumb.active{border-color:#fff}
.lib-anim-thumb .anim-preview-img{width:100%;aspect-ratio:1.6;display:block;background:#000;object-fit:cover}
.lib-anim-thumb span{font-size:9px;font-weight:700;color:var(--t3);padding:5px 8px;letter-spacing:.08em;text-transform:uppercase;transition:color .12s}
.lib-anim-thumb.active span,.lib-anim-thumb:hover span{color:var(--t2)}
/* Anim canvas overlay */
#animCanvas{position:absolute;inset:0;display:none;pointer-events:none}
/* Compositing hints */
#svgWrapper{will-change:transform}
.svg-container{contain:layout style}

/* Controls */
.ctrl{display:flex;flex-direction:column;gap:7px}
.ctrl-row{display:flex;align-items:center;justify-content:space-between}
.ctrl-label{font-size:11px;color:var(--t2);font-weight:400}
.ctrl-val{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--t2);font-weight:400;min-width:36px;text-align:right;}
input[type=range]{
  width:100%;height:2px;border-radius:2px;cursor:pointer;
  background:var(--s5);outline:none;border:none;-webkit-appearance:none;
}
input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;width:11px;height:11px;border-radius:50%;
  background:#fff;cursor:pointer;transition:transform .12s;
}
input[type=range]:hover::-webkit-slider-thumb{transform:scale(1.25)}
input[type=range]::-webkit-slider-runnable-track{
  height:2px;border-radius:2px;
  background:linear-gradient(to right,rgba(255,255,255,.5) var(--pct,50%),var(--s5) var(--pct,50%));
}

/* Select / Textarea */
.ctrl select,.ctrl textarea,.ctrl input[type=text]{
  background:var(--s3);border:1px solid var(--border);border-radius:6px;
  color:var(--text);font-size:11.5px;font-family:'Inter',sans-serif;
  padding:6px 10px;outline:none;width:100%;transition:border-color .12s;
  -webkit-appearance:none;
}
.ctrl select{
  cursor:pointer;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5'%3E%3Cpath d='M0 0l4 5 4-5z' fill='%23555'/%3E%3C/svg%3E");
  background-repeat:no-repeat;background-position:right 10px center;padding-right:26px;
}
.ctrl select:focus,.ctrl textarea:focus,.ctrl input[type=text]:focus{border-color:rgba(255,255,255,.18)}
.ctrl textarea{resize:vertical;min-height:50px;font-size:10.5px;line-height:1.6;font-family:'JetBrains Mono',monospace}

/* Toggle */
.toggle-row{display:flex;align-items:center;justify-content:space-between;min-height:22px}
.toggle{
  position:relative;width:30px;height:17px;border-radius:9px;
  background:var(--s5);cursor:pointer;transition:background .18s;border:none;flex-shrink:0;
}
.toggle.on{background:#fff}
.toggle::after{
  content:'';position:absolute;width:11px;height:11px;border-radius:50%;
  background:#444;top:3px;left:3px;transition:left .18s cubic-bezier(.4,0,.2,1),background .18s;
}
.toggle.on::after{left:16px;background:#000}

/* Char set grid */
.charset-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:3px}
.charset-option{
  padding:6px 4px;border-radius:5px;background:transparent;border:1px solid var(--border);
  font-family:'JetBrains Mono',monospace;font-size:9.5px;cursor:pointer;
  text-align:center;color:var(--t3);transition:all .12s;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.charset-option:hover{border-color:rgba(255,255,255,.15);color:var(--t2)}
.charset-option.active{border-color:rgba(255,255,255,.35);color:var(--text);background:rgba(255,255,255,.04)}

/* Color swatch */
.color-row{display:flex;gap:8px;align-items:center}
.color-swatch{width:26px;height:26px;border-radius:5px;border:1px solid var(--border);cursor:pointer;overflow:hidden;flex-shrink:0}
.color-swatch input[type=color]{width:200%;height:200%;margin:-25%;border:none;cursor:pointer;background:none}
.color-label{font-size:11px;color:var(--t2);flex:1}

/* Depth pills */
.depth-pills{display:flex;gap:3px}
.depth-pill{
  flex:1;padding:5px 4px;border-radius:5px;border:1px solid var(--border);
  background:transparent;font-size:10px;cursor:pointer;text-align:center;
  color:var(--t3);transition:all .12s;font-weight:600;
}
.depth-pill:hover{color:var(--t2);border-color:rgba(255,255,255,.15)}
.depth-pill.active{border-color:rgba(255,255,255,.35);color:var(--text);background:rgba(255,255,255,.04)}

/* ── Preview area ───────────────────────────────────────────── */
.preview{background:var(--bg);display:flex;flex-direction:column;overflow:hidden;position:relative;}

/* Drop zone */
.dropzone{
  flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;
  border:1px dashed rgba(255,255,255,.09);margin:16px;border-radius:12px;
  cursor:pointer;transition:all .2s;gap:10px;
}
.dropzone:hover,.dropzone.drag{border-color:rgba(255,255,255,.2);background:rgba(255,255,255,.01)}
.dropzone.hidden{display:none}
.dz-icon{font-size:28px;opacity:.1;font-family:'JetBrains Mono',monospace;letter-spacing:-2px}
.dz-title{font-size:13px;font-weight:600;color:var(--t2)}
.dz-sub{font-size:11px;color:var(--t3)}
.dz-formats{display:flex;gap:4px;margin-top:2px}
.dz-fmt{padding:2px 7px;border-radius:4px;background:var(--s3);font-size:9px;font-weight:700;color:var(--t3);font-family:'JetBrains Mono',monospace;letter-spacing:.04em}
.dz-samples{display:flex;gap:5px;margin-top:6px}
.sample-btn{
  padding:5px 12px;border-radius:6px;font-size:10.5px;font-weight:500;
  cursor:pointer;border:1px solid var(--border);background:transparent;
  color:var(--t2);transition:all .12s;font-family:inherit;
}
.sample-btn:hover{border-color:rgba(255,255,255,.18);color:var(--text)}

/* SVG Output */
.output-wrap{flex:1;overflow:hidden;display:none;flex-direction:column;position:relative;}
.output-wrap.visible{display:flex}
.svg-container{
  flex:1;overflow:auto;display:flex;align-items:center;justify-content:center;
  padding:32px;position:relative;
}
/* Always center the artboard regardless of zoom */
#svgWrapper{
  position:relative;display:inline-flex;
  align-items:center;justify-content:center;
  transform-origin:center center;
}
#asciiSvg{display:block;transform-origin:center center;cursor:grab;user-select:none;-webkit-user-select:none;}
#asciiSvg:active{cursor:grabbing}

/* Zoom bar */
.zoom-bar{
  position:absolute;bottom:12px;right:12px;
  display:flex;align-items:center;gap:4px;
  background:rgba(7,7,7,.92);border:1px solid var(--border);border-radius:8px;
  padding:4px 8px;backdrop-filter:blur(10px);
}
.zoom-btn{width:20px;height:20px;border-radius:4px;background:transparent;border:none;cursor:pointer;color:var(--t2);font-size:13px;display:flex;align-items:center;justify-content:center;transition:color .12s}
.zoom-btn:hover{color:var(--text)}
.zoom-val{font-size:10px;font-family:'JetBrains Mono',monospace;color:var(--t2);min-width:34px;text-align:center}

/* Info bar */
.info-bar{
  padding:5px 14px;border-top:1px solid var(--border);
  display:flex;align-items:center;gap:16px;flex-shrink:0;background:var(--s1);
}
.info-item{font-size:9.5px;color:var(--t3);font-family:'JetBrains Mono',monospace;display:flex;align-items:center;gap:5px}
.info-dot{width:4px;height:4px;border-radius:50%;background:var(--t3);flex-shrink:0}

/* Parallax indicator */
.parallax-badge{
  position:absolute;top:12px;left:12px;
  background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.1);
  border-radius:20px;padding:3px 10px;font-size:9.5px;font-weight:600;
  color:var(--t2);display:none;align-items:center;gap:5px;
  letter-spacing:.06em;text-transform:uppercase;backdrop-filter:blur(8px);
}
.parallax-badge.visible{display:flex}
.parallax-badge span{width:4px;height:4px;border-radius:50%;background:var(--t2);animation:pdot 1.4s ease infinite;flex-shrink:0}
@keyframes pdot{0%,100%{opacity:1}50%{opacity:.2}}

/* Processing spinner */
.processing{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);backdrop-filter:blur(6px);z-index:10;}
.processing.visible{display:flex}
.spinner{width:22px;height:22px;border-radius:50%;border:2px solid var(--s5);border-top-color:rgba(255,255,255,.5);animation:spin .7s linear infinite;}
@keyframes spin{to{transform:rotate(360deg)}}

/* Hidden inputs */
#fileInput{display:none}
#sampleCanvas{display:none}

/* ── Mode Switch ──────────────────────────────────────────── */
.mode-switch{display:flex;align-items:center;gap:2px;background:var(--s2);border:1px solid var(--border);border-radius:8px;padding:2px;flex-shrink:0}
.mode-btn{padding:4px 13px;border-radius:6px;font-size:10.5px;font-weight:600;cursor:pointer;border:none;background:transparent;color:var(--t2);transition:all .15s;font-family:inherit;letter-spacing:.04em}
.mode-btn.active{background:#fff;color:#000}

/* ASCII things hidden in dither mode */
body.dither-mode #asciiPresets{display:none}
body.dither-mode .ascii-sidebar{display:none}
body.dither-mode #asciiExportGroup{display:none}

/* Dither sidebar + export visible only in dither mode */
.dither-sidebar{display:none;flex-direction:column}
body.dither-mode .dither-sidebar{display:flex}
#ditherExportGroup{display:none}
body.dither-mode #ditherExportGroup{display:flex}

/* Dither output canvas */
#ditherCanvas{position:absolute;inset:0;display:none;pointer-events:none;image-rendering:pixelated}
#ditherCanvas.active{display:block}

/* Algorithm picker grid */
.algo-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:3px}
.algo-pill{padding:7px 4px;border-radius:5px;border:1px solid var(--border);background:transparent;font-size:9px;font-weight:600;cursor:pointer;text-align:center;color:var(--t3);transition:all .12s;font-family:inherit;letter-spacing:.02em;line-height:1.3}
.algo-pill:hover{color:var(--t2);border-color:rgba(255,255,255,.15)}
.algo-pill.active{border-color:rgba(255,255,255,.35);color:var(--text);background:rgba(255,255,255,.04)}

/* Dither no-image nudge */
.dither-no-img{padding:28px 16px;text-align:center;color:var(--t3);font-size:11px;line-height:1.7}
</style>
</head>
<body>
<div class="app">

<!-- ── TOPBAR ────────────────────────────────────────────────── -->
<header class="topbar">
  <div class="tb-brand">
    <img src="logo.svg" width="26" height="26" alt="ASCII Generator" style="display:block;flex-shrink:0"/>
    <div class="tb-title">ASCII<span>.</span>GENERATOR</div>
  </div>

  <div class="mode-switch">
    <button class="mode-btn active" id="modeAscii">ASCII</button>
    <button class="mode-btn" id="modeDither">Dither</button>
  </div>

  <div class="tb-center" id="asciiPresets">
    <button class="preset-btn active" data-preset="standard">Standard</button>
    <button class="preset-btn" data-preset="matrix">Matrix</button>
    <button class="preset-btn" data-preset="blueprint">Blueprint</button>
    <button class="preset-btn" data-preset="neon">Neon</button>
    <button class="preset-btn" data-preset="retro">Retro</button>
  </div>

  <div class="tb-right">
    <div class="tb-status" id="statusText">No image loaded</div>
    <div class="tb-divider"></div>
    <div class="export-group" id="asciiExportGroup">
      <button class="exp-btn" id="exportSvg">SVG</button>
      <button class="exp-btn" id="exportPng">PNG</button>
      <button class="exp-btn" id="exportTxt">TXT</button>
      <button class="exp-btn" id="copySvg">Copy</button>
    </div>
    <div class="export-group" id="ditherExportGroup">
      <button class="exp-btn" id="ditherExportPng">PNG</button>
      <button class="exp-btn" id="ditherExportSvg">SVG</button>
    </div>
    <button class="upload-btn" id="uploadBtn">↑ Upload</button>
    <input type="file" id="fileInput" accept="image/*"/>
  </div>
</header>

<div class="body">

<!-- ── SIDEBAR ──────────────────────────────────────────────── -->
<aside class="sidebar">

<div class="ascii-sidebar">
  <!-- IMAGE LIBRARY -->
  <div class="section">
    <div class="section-hdr open" data-section="library">
      Library <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-library" style="padding:0;gap:0">
      <div class="lib-tabs">
        <button class="lib-tab active" id="libTabImages">Images</button>
        <button class="lib-tab" id="libTabAnims">Animations</button>
      </div>
      <!-- Images panel -->
      <div class="lib-grid" id="libImgGrid">
        <div class="lib-thumb active" data-src="lib-checkered-flag.png" data-label="Checkered Flag" title="Checkered Flag">
          <img src="lib-checkered-flag.png" alt="Checkered Flag" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-peace-glove.png" data-label="Peace Glove" title="Peace Glove">
          <img src="lib-peace-glove.png" alt="Peace Glove" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-shaka-glove.png" data-label="Shaka Glove" title="Shaka Glove">
          <img src="lib-shaka-glove.png" alt="Shaka Glove" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-dice.png" data-label="Dice" title="Dice">
          <img src="lib-dice.png" alt="Dice" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-money.png" data-label="Money Roll" title="Money Roll">
          <img src="lib-money.png" alt="Money Roll" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-chess-knight.png" data-label="Chess Knight" title="Chess Knight">
          <img src="lib-chess-knight.png" alt="Chess Knight" loading="lazy"/>
        </div>
        <div class="lib-thumb" data-src="lib-fire-panther.png" data-label="Fire Panther" title="Fire Panther">
          <img src="lib-fire-panther.png" alt="Fire Panther" loading="lazy"/>
        </div>
      </div>
      <!-- Animations panel -->
      <div class="hidden" id="libAnimGrid">
        <!-- Color + export controls -->
        <div style="display:flex;align-items:center;gap:8px;padding:8px 12px 4px">
          <div class="ctrl-label" style="font-size:9.5px;font-weight:700;letter-spacing:.08em;text-transform:uppercase;color:var(--t3)">Color</div>
          <input type="color" id="animColorPicker" value="#ffffff" title="Animation color" style="width:26px;height:22px;padding:1px;border:1px solid var(--border);border-radius:5px;background:var(--s3);cursor:pointer;"/>
          <button class="exp-btn" id="exportAnimJson" title="Download Lottie JSON (loops in any Lottie player)" style="margin-left:auto;opacity:.4;pointer-events:none">↓ Lottie</button>
        </div>
        <div class="lib-anim-grid" style="display:grid">
          <div class="lib-anim-thumb" data-anim="symbol-tide" title="Symbol Tide">
            <img class="anim-preview-img" alt="Symbol Tide"/><span>Symbol Tide</span>
          </div>
          <div class="lib-anim-thumb" data-anim="noise-field" title="Noise Field">
            <img class="anim-preview-img" alt="Noise Field"/><span>Noise Field</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- CHARACTER SET -->
  <div class="section">
    <div class="section-hdr open" data-section="charset">
      Characters <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-charset">
      <div class="charset-grid" id="charsetGrid">
        <div class="charset-option active" data-charset="standard" title=" .:-=+*#%@">Dense</div>
        <div class="charset-option" data-charset="blocks" title=" ░▒▓█">Blocks</div>
        <div class="charset-option" data-charset="simple" title=" .-=+*#">Simple</div>
        <div class="charset-option" data-charset="binary" title=" 01">Binary</div>
        <div class="charset-option" data-charset="hex" title=" 0-F">Hex</div>
        <div class="charset-option" data-charset="braille" title="⠀⠁⠃⠇">Braille</div>
      </div>
      <div class="ctrl">
        <div class="ctrl-label">Custom charset</div>
        <textarea id="customCharset" placeholder="Type chars lightest→darkest&#10;e.g.:  .:-=+*#%@$" rows="2"> .:-=+*#%@$</textarea>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Size</div>
          <div class="ctrl-val" id="colsVal">120</div>
        </div>
        <input type="range" id="cols" min="20" max="300" value="80"/>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Invert characters</div>
        <button class="toggle" id="invertChars"></button>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Edge detection</div>
        <button class="toggle" id="edgeDetect"></button>
      </div>
    </div>
  </div>

  <!-- TYPOGRAPHY -->
  <div class="section">
    <div class="section-hdr open" data-section="typo">
      Typography <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-typo">
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Scale</div>
          <div class="ctrl-val" id="scaleVal">100%</div>
        </div>
        <input type="range" id="scaleSlider" min="10" max="400" value="100"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Font size</div>
          <div class="ctrl-val" id="fontSizeVal">10px</div>
        </div>
        <input type="range" id="fontSize" min="4" max="24" value="10"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Line height</div>
          <div class="ctrl-val" id="lineHeightVal">1.20</div>
        </div>
        <input type="range" id="lineHeight" min="80" max="180" value="120"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Letter spacing</div>
          <div class="ctrl-val" id="letterSpacingVal">0.0</div>
        </div>
        <input type="range" id="letterSpacing" min="-20" max="40" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-label">Font family</div>
        <select id="fontFamily">
          <option value="'JetBrains Mono',monospace">JetBrains Mono</option>
          <option value="'Courier New',monospace">Courier New</option>
          <option value="monospace">System Mono</option>
          <option value="'Lucida Console',monospace">Lucida Console</option>
        </select>
      </div>
    </div>
  </div>

  <!-- COLOR -->
  <div class="section">
    <div class="section-hdr open" data-section="color">
      Color <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-color">
      <div class="ctrl">
        <div class="ctrl-label">Mode</div>
        <select id="colorMode">
          <option value="color">Full color</option>
          <option value="mono">Monochrome</option>
          <option value="invert">Invert color</option>
          <option value="grayscale">Grayscale</option>
          <option value="sepia">Sepia</option>
          <option value="hue">Hue shift</option>
        </select>
      </div>
      <div class="color-row">
        <div class="color-swatch"><input type="color" id="bgColor" value="#000000"/></div>
        <div class="color-label">Background</div>
      </div>
      <div class="color-row" id="fgColorRow">
        <div class="color-swatch"><input type="color" id="fgColor" value="#00ff41"/></div>
        <div class="color-label">Foreground (mono)</div>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Brightness</div>
          <div class="ctrl-val" id="brightnessVal">0</div>
        </div>
        <input type="range" id="brightness" min="-100" max="100" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Contrast</div>
          <div class="ctrl-val" id="contrastVal">0</div>
        </div>
        <input type="range" id="contrast" min="-100" max="100" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Saturation</div>
          <div class="ctrl-val" id="saturationVal">100%</div>
        </div>
        <input type="range" id="saturation" min="0" max="200" value="100"/>
      </div>
      <div class="ctrl" id="hueRow" style="display:none">
        <div class="ctrl-row">
          <div class="ctrl-label">Hue shift</div>
          <div class="ctrl-val" id="hueVal">0°</div>
        </div>
        <input type="range" id="hue" min="0" max="360" value="0"/>
      </div>
    </div>
  </div>

  <!-- IMAGE PROCESSING -->
  <div class="section">
    <div class="section-hdr" data-section="img">
      Image Processing <span class="arrow">▾</span>
    </div>
    <div class="section-body hidden" id="body-img">
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Pre-blur</div>
          <div class="ctrl-val" id="blurVal">0</div>
        </div>
        <input type="range" id="blur" min="0" max="10" value="0" step="0.5"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Posterize</div>
          <div class="ctrl-val" id="posterizeVal">Off</div>
        </div>
        <input type="range" id="posterize" min="0" max="8" value="0" step="1"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Threshold</div>
          <div class="ctrl-val" id="thresholdVal">Off</div>
        </div>
        <input type="range" id="threshold" min="0" max="255" value="0"/>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Dithering (Floyd-Steinberg)</div>
        <button class="toggle" id="dithering"></button>
      </div>
    </div>
  </div>

  <!-- PARALLAX -->
  <div class="section">
    <div class="section-hdr" data-section="parallax">
      Parallax Effect <span class="arrow">▾</span>
    </div>
    <div class="section-body hidden" id="body-parallax">
      <div class="toggle-row">
        <div class="ctrl-label" style="font-weight:700">Enable parallax</div>
        <button class="toggle" id="parallaxToggle"></button>
      </div>
      <div id="parallaxControls" style="display:flex;flex-direction:column;gap:10px;opacity:.4;pointer-events:none">
        <div class="ctrl">
          <div class="ctrl-label">Depth layers</div>
          <div class="depth-pills">
            <div class="depth-pill active" data-layers="3">3</div>
            <div class="depth-pill" data-layers="5">5</div>
            <div class="depth-pill" data-layers="7">7</div>
          </div>
        </div>
        <div class="ctrl">
          <div class="ctrl-row">
            <div class="ctrl-label">Intensity</div>
            <div class="ctrl-val" id="parallaxIntVal">20px</div>
          </div>
          <input type="range" id="parallaxInt" min="5" max="80" value="20"/>
        </div>
        <div class="ctrl">
          <div class="ctrl-label">Mode</div>
          <select id="parallaxMode">
            <option value="mouse">Mouse tracking</option>
            <option value="scroll">Scroll parallax</option>
            <option value="auto">Auto animate</option>
            <option value="tilt">Device tilt</option>
          </select>
        </div>
        <div class="ctrl">
          <div class="ctrl-row">
            <div class="ctrl-label">Smoothing</div>
            <div class="ctrl-val" id="parallaxSmoothVal">0.08</div>
          </div>
          <input type="range" id="parallaxSmooth" min="1" max="20" value="8"/>
        </div>
        <div class="toggle-row">
          <div class="ctrl-label">Depth fog</div>
          <button class="toggle on" id="depthFog"></button>
        </div>
        <div class="toggle-row">
          <div class="ctrl-label">3D perspective</div>
          <button class="toggle on" id="perspective3d"></button>
        </div>
      </div>
    </div>
  </div>

</div><!-- /.ascii-sidebar -->

<!-- ── DITHER SIDEBAR ──────────────────────────────────────── -->
<div class="dither-sidebar">

  <!-- No image yet -->
  <div class="dither-no-img" id="ditherNoImg">
    Upload a photo to start dithering
    <br>
    <button class="upload-btn" id="ditherUploadBtn" style="margin-top:12px;font-size:10px">↑ Upload Image</button>
  </div>

  <!-- Algorithm -->
  <div class="section">
    <div class="section-hdr open" data-section="dither-algo">
      Algorithm <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-dither-algo">
      <div class="algo-grid">
        <button class="algo-pill active" data-algo="floyd">Floyd–<br>Steinberg</button>
        <button class="algo-pill" data-algo="atkinson">Atkinson</button>
        <button class="algo-pill" data-algo="stucki">Stucki</button>
        <button class="algo-pill" data-algo="sierra">Sierra</button>
        <button class="algo-pill" data-algo="bayer4">Bayer<br>4×4</button>
        <button class="algo-pill" data-algo="bayer8">Bayer<br>8×8</button>
      </div>
    </div>
  </div>

  <!-- Adjustments -->
  <div class="section">
    <div class="section-hdr open" data-section="dither-adj">
      Adjustments <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-dither-adj">
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Dot size</div>
          <div class="ctrl-val" id="dsizeVal">2px</div>
        </div>
        <input type="range" id="dsize" min="1" max="12" value="2" step="1"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Threshold</div>
          <div class="ctrl-val" id="dthreshVal">0</div>
        </div>
        <input type="range" id="dthresh" min="-100" max="100" value="0"/>
      </div>
      <div class="ctrl">
        <div class="ctrl-row">
          <div class="ctrl-label">Contrast</div>
          <div class="ctrl-val" id="dcontrastVal">0</div>
        </div>
        <input type="range" id="dcontrast" min="-100" max="100" value="0"/>
      </div>
      <div class="toggle-row">
        <div class="ctrl-label">Invert</div>
        <button class="toggle" id="dinvert"></button>
      </div>
    </div>
  </div>

  <!-- Colors -->
  <div class="section">
    <div class="section-hdr open" data-section="dither-colors">
      Colors <span class="arrow">▾</span>
    </div>
    <div class="section-body" id="body-dither-colors">
      <div class="color-row">
        <div class="color-swatch" style="background:#1a1a1a">
          <input type="color" id="dfg" value="#1a1a1a"/>
        </div>
        <div class="color-label">Dot color</div>
      </div>
      <div class="color-row">
        <div class="color-swatch" style="background:#b8c4e0">
          <input type="color" id="dbg" value="#b8c4e0"/>
        </div>
        <div class="color-label">Background</div>
      </div>
    </div>
  </div>

</div><!-- /.dither-sidebar -->

</aside>

<!-- ── PREVIEW ───────────────────────────────────────────────── -->
<main class="preview">
  <div class="processing" id="processing"><div class="spinner"></div></div>

  <!-- Drop zone -->
  <div class="dropzone" id="dropzone">
    <div class="dz-icon">▓░▒</div>
    <div class="dz-title">Drop image here or click to upload</div>
    <div class="dz-sub">Converts any photo to editable vector ASCII art</div>
    <div class="dz-formats">
      <div class="dz-fmt">PNG</div><div class="dz-fmt">JPG</div>
      <div class="dz-fmt">WEBP</div><div class="dz-fmt">GIF</div>
    </div>
    <div class="dz-samples">
      <button class="sample-btn" data-sample="gradient">Try gradient</button>
      <button class="sample-btn" data-sample="portrait">Try portrait</button>
      <button class="sample-btn" data-sample="landscape">Try landscape</button>
    </div>
  </div>

  <!-- Output -->
  <div class="output-wrap" id="outputWrap">
    <div class="parallax-badge" id="parallaxBadge"><span></span>PARALLAX ACTIVE</div>
    <div class="svg-container" id="svgContainer">
      <canvas id="animCanvas"></canvas>
      <canvas id="ditherCanvas"></canvas>
      <div id="svgWrapper">
        <svg id="asciiSvg" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>
    </div>
    <div class="zoom-bar">
      <button class="zoom-btn" id="zoomOut">−</button>
      <div class="zoom-val" id="zoomVal">100%</div>
      <button class="zoom-btn" id="zoomIn">+</button>
      <button class="zoom-btn" id="zoomFit" title="Fit to screen" style="font-size:10px">⊞</button>
      <button class="zoom-btn" id="resetPos" title="Reset position" style="font-size:10px">⌖</button>
    </div>
  </div>

  <!-- Info bar -->
  <div class="info-bar">
    <div class="info-item"><div class="info-dot"></div><span id="infoSize">—</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoChars">—</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoMode">color</span></div>
    <div class="info-item"><div class="info-dot"></div><span id="infoFile">no file</span></div>
  </div>
</main>

</div>
</div>

<!-- Hidden canvas for image processing -->
<canvas id="processingCanvas" style="display:none"></canvas>

<script>
// ═══════════════════════════════════════════════════════════════
//  CHARACTER SETS
// ═══════════════════════════════════════════════════════════════
const CHARSETS = {
  standard: ` .'"\`^",:;Il!i><~+_-?][}{1)(|/\\tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$`,
  blocks:   ` ░▒▓█`,
  simple:   ` .-=+*#%@`,
  binary:   ` 01`,
  hex:      ` 0123456789ABCDEF`,
  braille:  ` ⠁⠃⠇⠏⠟⠿⣿`,
};

const PRESETS = {
  standard: { colorMode:'color',   bgColor:'#000000', fgColor:'#ffffff', fontSize:10, cols:80,  lineHeight:120, invertChars:false, charset:'standard' },
  matrix:   { colorMode:'mono',    bgColor:'#000000', fgColor:'#00ff41', fontSize:10, cols:80,  lineHeight:120, invertChars:false, charset:'simple'   },
  blueprint:{ colorMode:'mono',    bgColor:'#0a1628', fgColor:'#4f8ef7', fontSize:9,  cols:90,  lineHeight:115, invertChars:false, charset:'standard'  },
  neon:     { colorMode:'hue',     bgColor:'#080010', fgColor:'#ff00ff', fontSize:11, cols:70,  lineHeight:125, invertChars:false, charset:'blocks'    },
  retro:    { colorMode:'sepia',   bgColor:'#1a0e00', fgColor:'#d4a850', fontSize:10, cols:80,  lineHeight:118, invertChars:false, charset:'standard'  },
};

// ═══════════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════════
let state = {
  // image
  imageLoaded: false,
  imageEl: null,
  imgW: 0, imgH: 0,
  // char
  charset: 'standard',
  customChars: ` .:-=+*#%@$`,
  cols: 80,
  invertChars: false,
  edgeDetect: false,
  dithering: false,
  // typo
  fontSize: 10,
  lineHeight: 1.20,
  letterSpacing: 0,
  fontFamily: `'JetBrains Mono',monospace`,
  // color
  colorMode: 'color',
  bgColor: '#000000',
  fgColor: '#00ff41',
  brightness: 0,
  contrast: 0,
  saturation: 100,
  hue: 0,
  // image proc
  blur: 0,
  posterize: 0,
  threshold: 0,
  // parallax
  parallaxEnabled: false,
  parallaxLayers: 3,
  parallaxInt: 20,
  parallaxMode: 'mouse',
  parallaxSmooth: 0.08,
  depthFog: true,
  perspective3d: true,
  // ui
  zoom: 1,
  // animation
  animColor: '#ffffff',
};

let asciiGrid = [];         // {char, r,g,b, brightness}[][]
let parallaxX = 0, parallaxY = 0;
let targetX = 0, targetY = 0;
let rafId = null;
let autoAngleT = 0;
let renderDebounce = null;

// ═══════════════════════════════════════════════════════════════
//  DOM REFS
// ═══════════════════════════════════════════════════════════════
const dropzone    = document.getElementById('dropzone');
const outputWrap  = document.getElementById('outputWrap');
const svgEl       = document.getElementById('asciiSvg');
const svgWrapper  = document.getElementById('svgWrapper');
const svgContainer= document.getElementById('svgContainer');
const fileInput   = document.getElementById('fileInput');
const canvas      = document.getElementById('processingCanvas');
const ctx         = canvas.getContext('2d', {willReadFrequently:true});
const processing  = document.getElementById('processing');
const parallaxBadge = document.getElementById('parallaxBadge');

// ═══════════════════════════════════════════════════════════════
//  IMAGE LOADING
// ═══════════════════════════════════════════════════════════════
function loadImageFile(file) {
  const url = URL.createObjectURL(file);
  loadImageUrl(url, file.name);
}

function loadImageUrl(url, name='image') {
  if(animRaf) stopAnimation();
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    state.imageEl = img;
    state.imgW = img.naturalWidth;
    state.imgH = img.naturalHeight;
    state.imageLoaded = true;
    document.getElementById('infoFile').textContent = name;
    showOutput();
    if (appMode === 'dither') {
      document.getElementById('ditherNoImg').style.display = 'none';
      scheduleDither();
    } else {
      scheduleRender();
    }
    URL.revokeObjectURL(url);
  };
  img.src = url;
}

function generateSampleImage(type) {
  const w = 600, h = 400;
  canvas.width = w; canvas.height = h;

  if(type === 'gradient') {
    const g = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,w/1.5);
    g.addColorStop(0,'#ffffff'); g.addColorStop(.3,'#cc88ff');
    g.addColorStop(.6,'#4466ff'); g.addColorStop(1,'#000000');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    // add some circles
    for(let i=0;i<8;i++){
      const r=20+Math.random()*80, cx=Math.random()*w, cy=Math.random()*h;
      const g2=ctx.createRadialGradient(cx,cy,0,cx,cy,r);
      g2.addColorStop(0,'rgba(255,255,255,.8)'); g2.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=g2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    }
  } else if(type === 'portrait') {
    // Face-like shape
    ctx.fillStyle='#1a1a2e'; ctx.fillRect(0,0,w,h);
    // Head
    const face=ctx.createRadialGradient(w/2,h/2-20,10,w/2,h/2-20,160);
    face.addColorStop(0,'#f0d0a0'); face.addColorStop(.7,'#d4a060'); face.addColorStop(1,'#1a1a2e');
    ctx.fillStyle=face; ctx.beginPath(); ctx.ellipse(w/2,h/2-20,150,170,0,0,Math.PI*2); ctx.fill();
    // Eyes
    ctx.fillStyle='rgba(0,0,0,.8)';
    ctx.beginPath(); ctx.ellipse(w/2-50,h/2-50,18,12,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(w/2+50,h/2-50,18,12,0,0,Math.PI*2); ctx.fill();
    // Eye highlights
    ctx.fillStyle='rgba(255,255,255,.8)';
    ctx.beginPath(); ctx.ellipse(w/2-43,h/2-55,5,4,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(w/2+57,h/2-55,5,4,0,0,Math.PI*2); ctx.fill();
    // Nose
    ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(w/2,h/2-30); ctx.lineTo(w/2-20,h/2+20); ctx.lineTo(w/2+20,h/2+20); ctx.stroke();
    // Mouth
    ctx.strokeStyle='rgba(180,80,80,.7)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(w/2,h/2+50,40,0.1,Math.PI-0.1); ctx.stroke();
    // Hair
    const hair=ctx.createLinearGradient(w/2-150,0,w/2+150,100);
    hair.addColorStop(0,'#1a0a00'); hair.addColorStop(1,'#4a2000');
    ctx.fillStyle=hair;
    ctx.beginPath(); ctx.ellipse(w/2,h/2-120,155,80,0,Math.PI,Math.PI*2); ctx.fill();
  } else { // landscape
    // Sky
    const sky=ctx.createLinearGradient(0,0,0,h*0.6);
    sky.addColorStop(0,'#0a0a30'); sky.addColorStop(.5,'#1a3a6a'); sky.addColorStop(1,'#2a6aa0');
    ctx.fillStyle=sky; ctx.fillRect(0,0,w,h*0.6);
    // Stars
    for(let i=0;i<80;i++){
      const x=Math.random()*w, y=Math.random()*h*0.5, r=Math.random()*1.5;
      ctx.fillStyle=`rgba(255,255,255,${0.3+Math.random()*.7})`;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    // Moon
    const moon=ctx.createRadialGradient(w*0.8,h*0.1,0,w*0.8,h*0.1,50);
    moon.addColorStop(0,'#ffffee'); moon.addColorStop(.8,'#ddddbb'); moon.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=moon; ctx.beginPath(); ctx.arc(w*0.8,h*0.1,50,0,Math.PI*2); ctx.fill();
    // Mountains
    ctx.fillStyle='#0d1f0d';
    ctx.beginPath(); ctx.moveTo(0,h*0.6);
    for(let x=0;x<=w;x+=30){
      const y=h*0.6-Math.sin(x/w*Math.PI*2)*h*0.25-Math.sin(x/w*Math.PI*5)*h*0.1;
      ctx.lineTo(x,y);
    }
    ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.fill();
    // Water reflection
    const water=ctx.createLinearGradient(0,h*0.65,0,h);
    water.addColorStop(0,'#0a2030'); water.addColorStop(1,'#050f18');
    ctx.fillStyle=water; ctx.fillRect(0,h*0.65,w,h*0.35);
    // Reflection shimmer
    for(let i=0;i<20;i++){
      const rx=Math.random()*w, ry=h*0.7+Math.random()*h*0.25;
      ctx.fillStyle=`rgba(100,150,200,${0.05+Math.random()*.15})`;
      ctx.fillRect(rx,ry,2+Math.random()*60,1);
    }
  }

  const dataUrl = canvas.toDataURL();
  const img = new Image();
  img.onload = () => {
    state.imageEl = img; state.imgW = w; state.imgH = h;
    state.imageLoaded = true;
    document.getElementById('infoFile').textContent = `sample-${type}`;
    showOutput(); scheduleRender();
  };
  img.src = dataUrl;
}

// ═══════════════════════════════════════════════════════════════
//  IMAGE PROCESSING
// ═══════════════════════════════════════════════════════════════
function getPixelData() {
  const cols = state.cols;
  const aspectCorrection = 0.45; // monospace chars are ~2:1 h:w
  const rows = Math.round(cols * (state.imgH / state.imgW) * aspectCorrection);

  canvas.width = cols; canvas.height = rows;
  ctx.clearRect(0,0,cols,rows);

  // Apply blur via CSS filter on offscreen
  ctx.filter = state.blur > 0 ? `blur(${state.blur}px)` : 'none';
  ctx.drawImage(state.imageEl, 0,0, cols, rows);
  ctx.filter = 'none';

  let data = ctx.getImageData(0,0,cols,rows);
  applyColorAdjust(data);
  if(state.posterize > 0) applyPosterize(data);
  if(state.threshold > 0) applyThreshold(data);
  if(state.edgeDetect) data = applySobel(data, cols, rows);
  if(state.dithering) applyDither(data, cols, rows);
  return {data, cols, rows};
}

function applyColorAdjust(imageData) {
  const d = imageData.data;
  const b = state.brightness / 100;
  const c = (state.contrast / 100);
  const cFactor = (259*(c*255+255)) / (255*(259-c*255));
  const sat = state.saturation / 100;
  const hDeg = state.hue;

  for(let i=0;i<d.length;i+=4) {
    let r=d[i]/255, g=d[i+1]/255, bl=d[i+2]/255;
    // brightness
    r+=b; g+=b; bl+=b;
    // contrast
    r=cFactor*(r-.5)+.5; g=cFactor*(g-.5)+.5; bl=cFactor*(bl-.5)+.5;
    // saturation
    const lum = 0.299*r+0.587*g+0.114*bl;
    r=lum+(r-lum)*sat; g=lum+(g-lum)*sat; bl=lum+(bl-lum)*sat;
    // hue shift
    if(hDeg!==0) { const [hh,ss,vv]=rgbToHsv(r,g,bl); [r,g,bl]=hsvToRgb((hh+hDeg/360)%1,ss,vv); }
    // clamp
    d[i]  =Math.max(0,Math.min(255,r*255));
    d[i+1]=Math.max(0,Math.min(255,g*255));
    d[i+2]=Math.max(0,Math.min(255,bl*255));
  }
  ctx.putImageData(imageData,0,0);
}

function applyPosterize(imageData) {
  const d=imageData.data; const levels=state.posterize;
  for(let i=0;i<d.length;i+=4){
    d[i]  =Math.round(d[i]  /255*levels)/levels*255;
    d[i+1]=Math.round(d[i+1]/255*levels)/levels*255;
    d[i+2]=Math.round(d[i+2]/255*levels)/levels*255;
  }
  ctx.putImageData(imageData,0,0);
}

function applyThreshold(imageData) {
  const d=imageData.data; const t=state.threshold;
  for(let i=0;i<d.length;i+=4){
    const lum=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    const v=lum>t?255:0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(imageData,0,0);
}

function applySobel(imageData, w, h) {
  const src=imageData.data; const out=ctx.createImageData(w,h); const od=out.data;
  const kx=[[-1,0,1],[-2,0,2],[-1,0,1]];
  const ky=[[-1,-2,-1],[0,0,0],[1,2,1]];
  for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){
    let gx=0,gy=0;
    for(let ky2=0;ky2<3;ky2++){for(let kx2=0;kx2<3;kx2++){
      const px=((y+ky2-1)*w+(x+kx2-1))*4;
      const lum=0.299*src[px]+0.587*src[px+1]+0.114*src[px+2];
      gx+=lum*kx[ky2][kx2]; gy+=lum*ky[ky2][kx2];
    }}
    const mag=Math.min(255,Math.sqrt(gx*gx+gy*gy));
    const i=(y*w+x)*4;
    od[i]=od[i+1]=od[i+2]=mag; od[i+3]=255;
  }}
  ctx.putImageData(out,0,0); return out;
}

function applyDither(imageData, w, h) {
  const d=imageData.data;
  for(let y=0;y<h;y++){for(let x=0;x<w;x++){
    const i=(y*w+x)*4;
    const old=[d[i],d[i+1],d[i+2]];
    const nw=old.map(v=>v>127?255:0);
    [d[i],d[i+1],d[i+2]]=[nw[0],nw[1],nw[2]];
    const err=old.map((v,k)=>v-nw[k]);
    const spread=[[1,0,7/16],[- 1,1,3/16],[0,1,5/16],[1,1,1/16]];
    spread.forEach(([dx,dy,f])=>{
      const nx=x+dx,ny=y+dy;
      if(nx>=0&&nx<w&&ny>=0&&ny<h){
        const ni=(ny*w+nx)*4;
        for(let c=0;c<3;c++) d[ni+c]=Math.max(0,Math.min(255,d[ni+c]+err[c]*f));
      }
    });
  }}
  ctx.putImageData(imageData,0,0);
}

// ═══════════════════════════════════════════════════════════════
//  ASCII CONVERSION
// ═══════════════════════════════════════════════════════════════
function convertToAscii() {
  const {data,cols,rows} = getPixelData();
  const d = data.data;
  const chars = state.charset==='custom'
    ? state.customChars
    : CHARSETS[state.charset] || CHARSETS.standard;

  const grid = [];
  for(let r=0;r<rows;r++){
    const row=[];
    for(let c=0;c<cols;c++){
      const i=(r*cols+c)*4;
      const rv=d[i], gv=d[i+1], bv=d[i+2];
      let lum=0.299*rv+0.587*gv+0.114*bv;

      // Apply color mode transformations for char lookup
      let charLum=lum/255;
      if(state.invertChars) charLum=1-charLum;

      const charIdx = Math.max(0,Math.min(chars.length-1,
        Math.floor(charLum*(chars.length-1))));
      const ch = chars[charIdx];

      // Color output
      let fr=rv, fg=gv, fb=bv;
      if(state.colorMode==='mono'){ const [fr2,fg2,fb2]=hexToRgb(state.fgColor); fr=fr2;fg=fg2;fb=fb2; }
      else if(state.colorMode==='grayscale'){ fr=fg=fb=lum; }
      else if(state.colorMode==='invert'){ fr=255-rv;fg=255-gv;fb=255-bv; }
      else if(state.colorMode==='sepia'){ fr=rv*.393+gv*.769+bv*.189; fg=rv*.349+gv*.686+bv*.168; fb=rv*.272+gv*.534+bv*.131; }

      // Depth layer for parallax (0 = dark background, N = bright foreground)
      const depthLayer = Math.floor(charLum * (state.parallaxLayers - 1));

      row.push({ ch, r:fr, g:fg, b:fb, lum:charLum, depth:depthLayer });
    }
    grid.push(row);
  }
  return {grid, cols, rows};
}

// ═══════════════════════════════════════════════════════════════
//  SVG RENDERING
// ═══════════════════════════════════════════════════════════════
function renderSVG({grid, cols, rows}) {
  const fs = state.fontSize;
  const lh = state.lineHeight;
  const ls = state.letterSpacing / 10; // convert from slider (tenths em)
  const fw = fs * 0.6 + ls; // approx char width
  const fh = fs * lh;
  const svgW = cols * fw;
  const svgH = rows * fh;
  const bg = state.bgColor;
  const ff = state.fontFamily;

  // Build layers
  const numLayers = state.parallaxEnabled ? state.parallaxLayers : 1;
  const layerBuffers = Array.from({length:numLayers}, ()=>[]);

  grid.forEach((row, ri) => {
    const y = ri * fh + fs; // baseline
    row.forEach((cell, ci) => {
      if(cell.ch===' ') return; // skip spaces
      const x = ci * fw;
      const color = `rgb(${Math.round(cell.r)},${Math.round(cell.g)},${Math.round(cell.b)})`;
      const layer = state.parallaxEnabled ? cell.depth : 0;

      // Depth fog: deeper layers more transparent
      let opacity = 1;
      if(state.parallaxEnabled && state.depthFog) {
        opacity = 0.3 + (cell.depth / (numLayers-1)) * 0.7;
      }

      const opacityAttr = opacity < 0.99 ? ` opacity="${opacity.toFixed(2)}"` : '';
      layerBuffers[layer].push(
        `<text x="${x.toFixed(1)}" y="${y.toFixed(1)}" fill="${color}"${opacityAttr}>${cell.ch==='&'?'&amp;':cell.ch==='<'?'&lt;':cell.ch}</text>`
      );
    });
  });

  // Build SVG
  let svgContent = `<rect width="${svgW}" height="${svgH}" fill="${bg}"/>`;

  if(state.parallaxEnabled) {
    layerBuffers.forEach((buf,i) => {
      const depthName = `layer-${i}`;
      svgContent += `<g class="plx-layer" data-layer="${i}" id="${depthName}" style="will-change:transform">${buf.join('')}</g>`;
    });
  } else {
    svgContent += `<g>${layerBuffers[0].join('')}</g>`;
  }

  const lsAttr = ls !== 0 ? ` letter-spacing="${ls.toFixed(2)}em"` : '';
  svgEl.setAttribute('viewBox',`0 0 ${svgW} ${svgH}`);
  svgEl.setAttribute('width', svgW);
  svgEl.setAttribute('height', svgH);
  svgEl.setAttribute('style',`font-family:${ff};font-size:${fs}px;background:${bg}`);
  svgEl.innerHTML = `<style>text{${lsAttr?`letter-spacing:${ls.toFixed(2)}em;`:''}dominant-baseline:auto}</style>${svgContent}`;

  // Update info
  const totalChars = grid.reduce((s,r)=>s+r.filter(c=>c.ch!==' ').length,0);
  document.getElementById('infoSize').textContent = `${cols}×${rows}`;
  document.getElementById('infoChars').textContent = `${totalChars.toLocaleString()} chars`;
  document.getElementById('infoMode').textContent = state.colorMode;
  document.getElementById('statusText').textContent = `${cols}c × ${rows}r · ${totalChars.toLocaleString()} chars`;

  // Apply zoom
  applyZoom();
  asciiGrid = grid;
}

// ═══════════════════════════════════════════════════════════════
//  PARALLAX ENGINE
// ═══════════════════════════════════════════════════════════════
function startParallax() {
  if(rafId) cancelAnimationFrame(rafId);
  parallaxX=0; parallaxY=0; targetX=0; targetY=0;
  parallaxBadge.classList.add('visible');

  const mode = state.parallaxMode;

  if(mode==='mouse') {
    svgContainer.addEventListener('mousemove', onMouseMove);
    svgContainer.addEventListener('mouseleave', onMouseLeave);
  } else if(mode==='scroll') {
    svgContainer.addEventListener('wheel', onWheel, {passive:true});
  } else if(mode==='tilt' && window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', onTilt);
  }

  animateParallax();
}

function stopParallax() {
  if(rafId) cancelAnimationFrame(rafId); rafId=null;
  svgContainer.removeEventListener('mousemove', onMouseMove);
  svgContainer.removeEventListener('mouseleave', onMouseLeave);
  svgContainer.removeEventListener('wheel', onWheel);
  window.removeEventListener('deviceorientation', onTilt);
  parallaxBadge.classList.remove('visible');
  // Reset transforms
  document.querySelectorAll('.plx-layer').forEach(l=>{ l.style.transform=''; });
  if(state.perspective3d) svgWrapper.style.transform='';
}

function onMouseMove(e) {
  const rect = svgContainer.getBoundingClientRect();
  targetX = ((e.clientX - rect.left) / rect.width  - 0.5) * 2;
  targetY = ((e.clientY - rect.top)  / rect.height - 0.5) * 2;
}
function onMouseLeave() { targetX=0; targetY=0; }
function onWheel(e) { targetY = Math.max(-1,Math.min(1, targetY + e.deltaY*0.002)); }
function onTilt(e) {
  targetX = (e.gamma||0)/45;
  targetY = ((e.beta||0)-45)/45;
}

function animateParallax() {
  const smooth = state.parallaxSmooth;
  parallaxX += (targetX - parallaxX) * smooth;
  parallaxY += (targetY - parallaxY) * smooth;

  if(state.parallaxMode==='auto') {
    autoAngleT += 0.008;
    parallaxX = Math.sin(autoAngleT)*0.6;
    parallaxY = Math.cos(autoAngleT*0.7)*0.4;
  }

  const layers = document.querySelectorAll('.plx-layer');
  const n = layers.length;
  const intensity = state.parallaxInt;

  layers.forEach((layer,i) => {
    // i=0 is darkest (background), i=n-1 is brightest (foreground)
    const t = n>1 ? (i/(n-1)) : 0;
    const depthFactor = (t - 0.5) * 2; // -1 to +1
    const dx = parallaxX * depthFactor * intensity;
    const dy = parallaxY * depthFactor * intensity;
    layer.style.transform = `translate(${dx.toFixed(2)}px,${dy.toFixed(2)}px)`;
  });

  if(state.perspective3d && n>0) {
    const rotX = parallaxY * -8;
    const rotY = parallaxX * 8;
    svgWrapper.style.transform = `perspective(800px) rotateX(${rotX.toFixed(2)}deg) rotateY(${rotY.toFixed(2)}deg)`;
    svgWrapper.style.transformStyle = 'preserve-3d';
  }

  rafId = requestAnimationFrame(animateParallax);
}

// ═══════════════════════════════════════════════════════════════
//  RENDER PIPELINE
// ═══════════════════════════════════════════════════════════════
function scheduleRender() {
  if(animKey) return;           // animation active — skip
  if(appMode === 'dither') return; // dither mode active — skip
  clearTimeout(renderDebounce);
  processing.classList.add('visible');
  renderDebounce = setTimeout(doRender, 200);
}

function doRender() {
  if(!state.imageLoaded) { processing.classList.remove('visible'); return; }
  try {
    const result = convertToAscii();
    renderSVG(result);
    if(state.parallaxEnabled) startParallax(); else stopParallax();
  } catch(e) { console.error(e); }
  processing.classList.remove('visible');
}

// ═══════════════════════════════════════════════════════════════
//  ZOOM
// ═══════════════════════════════════════════════════════════════
// ── Pan state ──────────────────────────────────────────────────
let panX = 0, panY = 0, isPanning = false, panStartX = 0, panStartY = 0;

function applyZoom() {
  svgWrapper.style.transform = `translate(${panX}px,${panY}px) scale(${state.zoom})`;
  svgWrapper.style.transformOrigin = 'center center';
  const pct = Math.round(state.zoom*100);
  document.getElementById('zoomVal').textContent = pct+'%';
  const slider = document.getElementById('scaleSlider');
  slider.value = Math.min(400, Math.max(10, pct));
  document.getElementById('scaleVal').textContent = pct+'%';
  updateSliderFill(slider);
}
function fitZoom() {
  const w = svgContainer.clientWidth - 64;
  const h = svgContainer.clientHeight - 64;
  const svgW = parseFloat(svgEl.getAttribute('width')||500);
  const svgH = parseFloat(svgEl.getAttribute('height')||400);
  state.zoom = Math.min(w/svgW, h/svgH, 1);
  panX = 0; panY = 0;
  applyZoom();
}
function resetPosition() {
  panX = 0; panY = 0; state.zoom = 1;
  applyZoom();
}

// Drag to pan
svgContainer.addEventListener('mousedown', e => {
  if(e.target === svgEl || svgEl.contains(e.target)) {
    isPanning = true;
    panStartX = e.clientX - panX;
    panStartY = e.clientY - panY;
    svgContainer.style.cursor = 'grabbing';
  }
});
window.addEventListener('mousemove', e => {
  if(!isPanning) return;
  panX = e.clientX - panStartX;
  panY = e.clientY - panStartY;
  applyZoom();
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  svgContainer.style.cursor = '';
});

// ═══════════════════════════════════════════════════════════════
//  EXPORT
// ═══════════════════════════════════════════════════════════════
function exportSVG() {
  const svgClone = svgEl.cloneNode(true);
  // Remove background fill rect (first direct child rect)
  const children = svgClone.children;
  for(let i=0;i<children.length;i++){
    if(children[i].tagName==='rect' && !children[i].getAttribute('class')){
      children[i].remove(); break;
    }
  }
  const s = new XMLSerializer().serializeToString(svgClone);
  const blob = new Blob([s], {type:'image/svg+xml'});
  dlBlob(blob,'ascii-art.svg');
}

function exportPNG() {
  const svgW = parseFloat(svgEl.getAttribute('width'));
  const svgH = parseFloat(svgEl.getAttribute('height'));
  const scale = 2;
  const svgClone = svgEl.cloneNode(true);
  // Remove background rect
  const children = svgClone.children;
  for(let i=0;i<children.length;i++){
    if(children[i].tagName==='rect' && !children[i].getAttribute('class')){
      children[i].remove(); break;
    }
  }
  // Strip background from SVG element's inline style
  const currentStyle = svgClone.getAttribute('style') || '';
  svgClone.setAttribute('style', currentStyle.replace(/background\s*:[^;]+;?/g, ''));
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = svgW*scale; tmpCanvas.height = svgH*scale;
  const tmpCtx = tmpCanvas.getContext('2d');
  const s = new XMLSerializer().serializeToString(svgClone);
  const blob = new Blob([s],{type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const img2 = new Image();
  img2.onload = () => {
    tmpCtx.clearRect(0,0,tmpCanvas.width,tmpCanvas.height);
    tmpCtx.drawImage(img2,0,0,svgW*scale,svgH*scale);
    tmpCanvas.toBlob(b=>{ dlBlob(b,'ascii-art.png'); URL.revokeObjectURL(url); },'image/png');
  };
  img2.src = url;
}

function exportTXT() {
  const txt = asciiGrid.map(r=>r.map(c=>c.ch).join('')).join('\n');
  dlBlob(new Blob([txt],{type:'text/plain'}),'ascii-art.txt');
}

function copySVG() {
  const s = new XMLSerializer().serializeToString(svgEl);
  navigator.clipboard.writeText(s).then(()=>{
    const btn = document.getElementById('copySvg');
    btn.textContent='✓ Copied'; setTimeout(()=>btn.textContent='⧉ Copy',1500);
  });
}

function dlBlob(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}

// ═══════════════════════════════════════════════════════════════
//  PRESETS
// ═══════════════════════════════════════════════════════════════
function applyPreset(name) {
  const p = PRESETS[name]; if(!p) return;
  Object.assign(state, {
    colorMode: p.colorMode,
    bgColor: p.bgColor,
    fgColor: p.fgColor,
    fontSize: p.fontSize,
    cols: p.cols,
    lineHeight: p.lineHeight / 100,
    invertChars: p.invertChars,
    charset: p.charset,
  });
  syncUI(); scheduleRender();
  document.getElementById('bgColor').value = p.bgColor;
  document.getElementById('fgColor').value = p.fgColor;
  // Sync animation color + charset to preset theme
  const ac=ANIM_PRESET_COLORS[name];
  if(ac){ state.animColor=ac; const pk=document.getElementById('animColorPicker'); if(pk) pk.value=ac; }
  updateAnimChars();
}

function syncUI() {
  // Sliders
  const sliders = {
    cols: state.cols,
    fontSize: state.fontSize,
    lineHeight: Math.round(state.lineHeight*100),
    letterSpacing: state.letterSpacing,
    brightness: state.brightness,
    contrast: state.contrast,
    saturation: state.saturation,
    hue: state.hue,
    blur: state.blur,
    posterize: state.posterize,
    threshold: state.threshold,
    parallaxInt: state.parallaxInt,
    parallaxSmooth: Math.round(state.parallaxSmooth*100),
  };
  Object.entries(sliders).forEach(([id,v])=>{
    const el=document.getElementById(id); if(el){el.value=v; updateSliderFill(el);}
  });
  updateAllVals();
  document.getElementById('colorMode').value = state.colorMode;
  document.getElementById('fontFamily').value = state.fontFamily;
  // charset
  document.querySelectorAll('.charset-option').forEach(el=>{
    el.classList.toggle('active', el.dataset.charset===state.charset);
  });
}

// ═══════════════════════════════════════════════════════════════
//  UI HELPERS
// ═══════════════════════════════════════════════════════════════
function showOutput() {
  dropzone.classList.add('hidden');
  outputWrap.classList.add('visible');
}

function updateAllVals() {
  const set = (id,v)=>{ const el=document.getElementById(id); if(el) el.textContent=v; };
  set('colsVal',       state.cols);
  set('fontSizeVal',   state.fontSize+'px');
  set('lineHeightVal', state.lineHeight.toFixed(2));
  set('letterSpacingVal', (state.letterSpacing/10).toFixed(1));
  set('brightnessVal', (state.brightness>0?'+':'')+state.brightness);
  set('contrastVal',   (state.contrast>0?'+':'')+state.contrast);
  set('saturationVal', state.saturation+'%');
  set('hueVal',        state.hue+'°');
  set('blurVal',       state.blur||'Off');
  set('posterizeVal',  state.posterize||'Off');
  set('thresholdVal',  state.threshold||'Off');
  set('parallaxIntVal',state.parallaxInt+'px');
  set('parallaxSmoothVal',(state.parallaxSmooth).toFixed(2));
}

function updateSliderFill(el) {
  const min=+el.min, max=+el.max, val=+el.value;
  const pct = ((val-min)/(max-min)*100).toFixed(1)+'%';
  el.style.setProperty('--pct', pct);
}

function toggleEl(id) {
  const btn = document.getElementById(id);
  btn.classList.toggle('on');
  return btn.classList.contains('on');
}

function hexToRgb(hex) {
  const r=parseInt(hex.slice(1,3),16);
  const g=parseInt(hex.slice(3,5),16);
  const b=parseInt(hex.slice(5,7),16);
  return [r,g,b];
}
function rgbToHsv(r,g,b){
  const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min;
  let h=0;
  if(d){if(max===r)h=(g-b)/d%6;else if(max===g)h=(b-r)/d+2;else h=(r-g)/d+4; h/=6; if(h<0)h+=1;}
  return [h, max?d/max:0, max];
}
function hsvToRgb(h,s,v){
  const i=Math.floor(h*6),f=h*6-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s);
  const m=i%6;
  if(m===0)return[v,t,p];if(m===1)return[q,v,p];if(m===2)return[p,v,t];
  if(m===3)return[p,q,v];if(m===4)return[t,p,v];return[v,p,q];
}

// ═══════════════════════════════════════════════════════════════
//  EVENT WIRING
// ═══════════════════════════════════════════════════════════════

// Upload
document.getElementById('uploadBtn').addEventListener('click',()=>fileInput.click());
fileInput.addEventListener('change',e=>{ if(e.target.files[0]) loadImageFile(e.target.files[0]); });

// Drop zone
dropzone.addEventListener('click',()=>fileInput.click());
document.body.addEventListener('dragover',e=>{e.preventDefault();dropzone.classList.add('drag')});
document.body.addEventListener('dragleave',()=>dropzone.classList.remove('drag'));
document.body.addEventListener('drop',e=>{
  e.preventDefault(); dropzone.classList.remove('drag');
  if(e.dataTransfer.files[0]) loadImageFile(e.dataTransfer.files[0]);
});

// Sample buttons
document.querySelectorAll('.sample-btn').forEach(btn=>{
  btn.addEventListener('click',()=>generateSampleImage(btn.dataset.sample));
});

// Presets
document.querySelectorAll('.preset-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.preset-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    applyPreset(btn.dataset.preset);
  });
});

// Charset
document.querySelectorAll('.charset-option').forEach(opt=>{
  opt.addEventListener('click',()=>{
    document.querySelectorAll('.charset-option').forEach(o=>o.classList.remove('active'));
    opt.classList.add('active');
    state.charset = opt.dataset.charset;
    scheduleRender();
    updateAnimChars();
  });
});
document.getElementById('customCharset').addEventListener('input',e=>{
  state.customChars = e.target.value || ' .:#@';
  state.charset = 'custom';
  document.querySelectorAll('.charset-option').forEach(o=>o.classList.remove('active'));
  scheduleRender();
  updateAnimChars();
});

// Sliders
function wireSlider(id, stateKey, transform, displayFn) {
  const el = document.getElementById(id);
  el.addEventListener('input',()=>{
    updateSliderFill(el);
    state[stateKey] = transform ? transform(+el.value) : +el.value;
    updateAllVals();
    scheduleRender();
  });
  updateSliderFill(el);
}
wireSlider('cols',          'cols',          null);
wireSlider('fontSize',      'fontSize',      null);
wireSlider('lineHeight',    'lineHeight',    v=>v/100);
wireSlider('letterSpacing', 'letterSpacing', null);
wireSlider('brightness',    'brightness',    null);
wireSlider('contrast',      'contrast',      null);
wireSlider('saturation',    'saturation',    null);
wireSlider('hue',           'hue',           null);
wireSlider('blur',          'blur',          null);
wireSlider('posterize',     'posterize',     null);
wireSlider('threshold',     'threshold',     null);
wireSlider('parallaxInt',   'parallaxInt',   null);
wireSlider('parallaxSmooth','parallaxSmooth',v=>v/100);

// Selects
document.getElementById('colorMode').addEventListener('change',e=>{
  state.colorMode=e.target.value;
  document.getElementById('hueRow').style.display=e.target.value==='hue'?'flex':'none';
  scheduleRender();
});
document.getElementById('fontFamily').addEventListener('change',e=>{ state.fontFamily=e.target.value; scheduleRender(); });

// Color pickers
document.getElementById('bgColor').addEventListener('input',e=>{ state.bgColor=e.target.value; scheduleRender(); });
document.getElementById('fgColor').addEventListener('input',e=>{ state.fgColor=e.target.value; scheduleRender(); });

// Toggles
document.getElementById('invertChars').addEventListener('click',()=>{ state.invertChars=toggleEl('invertChars'); scheduleRender(); });
document.getElementById('edgeDetect').addEventListener('click',()=>{ state.edgeDetect=toggleEl('edgeDetect'); scheduleRender(); });
document.getElementById('dithering').addEventListener('click',()=>{ state.dithering=toggleEl('dithering'); scheduleRender(); });
document.getElementById('depthFog').addEventListener('click',()=>{ state.depthFog=toggleEl('depthFog'); scheduleRender(); });
document.getElementById('perspective3d').addEventListener('click',()=>{ state.perspective3d=toggleEl('perspective3d'); });

// Parallax toggle
document.getElementById('parallaxToggle').addEventListener('click',()=>{
  state.parallaxEnabled=toggleEl('parallaxToggle');
  const ctrl=document.getElementById('parallaxControls');
  ctrl.style.opacity=state.parallaxEnabled?'1':'0.4';
  ctrl.style.pointerEvents=state.parallaxEnabled?'auto':'none';
  scheduleRender();
});
document.getElementById('parallaxMode').addEventListener('change',e=>{ state.parallaxMode=e.target.value; if(state.parallaxEnabled&&state.imageLoaded){stopParallax();startParallax();} });

// Depth pills
document.querySelectorAll('.depth-pill').forEach(pill=>{
  pill.addEventListener('click',()=>{
    document.querySelectorAll('.depth-pill').forEach(p=>p.classList.remove('active'));
    pill.classList.add('active');
    state.parallaxLayers=parseInt(pill.dataset.layers);
    scheduleRender();
  });
});

// Zoom
document.getElementById('zoomIn').addEventListener('click',()=>{ state.zoom=Math.min(4,state.zoom+0.1); applyZoom(); });
document.getElementById('zoomOut').addEventListener('click',()=>{ state.zoom=Math.max(0.1,state.zoom-0.1); applyZoom(); });
document.getElementById('zoomFit').addEventListener('click',fitZoom);
document.getElementById('resetPos').addEventListener('click',resetPosition);

// Scale slider (synced with zoom)
document.getElementById('scaleSlider').addEventListener('input',e=>{
  state.zoom = +e.target.value / 100;
  updateSliderFill(e.target);
  applyZoom();
});

// Mouse wheel zoom in preview
svgContainer.addEventListener('wheel',e=>{
  if(!e.ctrlKey) return;
  e.preventDefault();
  state.zoom = Math.max(0.1,Math.min(4, state.zoom - e.deltaY*0.001));
  applyZoom();
},{passive:false});

// Export
document.getElementById('exportSvg').addEventListener('click',exportSVG);
document.getElementById('exportPng').addEventListener('click',exportPNG);
document.getElementById('exportTxt').addEventListener('click',exportTXT);
document.getElementById('copySvg').addEventListener('click',copySVG);

// ═══════════════════════════════════════════════════════════════
//  ANIMATION LIBRARY  (SVG DOM — crisp at any DPR)
// ═══════════════════════════════════════════════════════════════
const animCanvas = document.getElementById('animCanvas');
let animRaf = null, animKey = null, animStateObj = null, animPrevT = 0;

// Preset → animation foreground color
const ANIM_PRESET_COLORS = {
  standard:'#ffffff', matrix:'#00ff41', blueprint:'#4f8ef7',
  neon:'#ff00ff', retro:'#d4a850'
};

// Symbol chars per charset (for Symbol Tide)
function getAnimSymbols(charset) {
  const map = {
    standard:'@#?+×!*=&%$~^÷±∑∏√∫∂∇',
    blocks:  '░▒▓█',
    simple:  '#*=+-?!.',
    binary:  '01',
    hex:     '0123456789ABCDEF',
    braille: '⠁⠃⠇⠏⠟⠿⣿',
  };
  return map[charset] || map.standard;
}

// Brightness-gradient chars per charset (for Noise Field)
function getAnimGradient(charset) {
  const map = {
    standard:[' ','.',':','-','=','+','*','#','%','@'],
    blocks:  [' ','░','▒','▓','█'],
    simple:  [' ','.','=','*','#'],
    binary:  [' ','0','1'],
    hex:     [' ','0','1','3','7','A','C','E','F'],
    braille: [' ','⠁','⠃','⠇','⠏','⠟','⠿','⣿'],
  };
  return map[charset] || map.standard;
}

const ANIMATIONS = {

  /* ── SYMBOL TIDE ─────────────────────────────────────────────── */
  'symbol-tide': {
    label:'Symbol Tide',
    createState(w,h){
      // sz=16: fewer cells = much less work per frame on low-end hardware
      const sz=16, chars=getAnimSymbols(state.charset);
      const cols=Math.ceil(w/sz), rows=Math.ceil(h/sz);
      return {
        sz,w,h,cols,rows,chars,
        grid:Array.from({length:rows},()=>
          Array.from({length:cols},()=>({
            char:chars[Math.floor(Math.random()*chars.length)],
            alpha:Math.random()*0.3,
            base:0.04+Math.random()*0.25,
            speed:0.006+Math.random()*0.014,
            changeAt:Math.random()*3000,
            displayAlpha:0
          }))
        )
      };
    },
    stepPhysics(s,dt,t){
      const {grid,chars,w,h,sz}=s;
      const w1x=((t*0.00018)%2-0.5)*w;
      const w2x=((t*0.00013+0.7)%2-0.5)*w;
      const w2y=((t*0.00009)%2-0.5)*h;
      for(let r=0;r<grid.length;r++) for(let c=0;c<grid[r].length;c++){
        const cell=grid[r][c];
        cell.alpha+=(cell.base-cell.alpha)*cell.speed*(dt/16);
        if(t>cell.changeAt){
          cell.base=0.03+Math.random()*0.3;
          cell.changeAt=t+200+Math.random()*3000;
          if(Math.random()>0.5) cell.char=chars[Math.floor(Math.random()*chars.length)];
        }
        const px=c*sz,py=r*sz;
        const d1=px-w1x,d2=px-w2x+py-w2y;
        const b1=Math.max(0,1-(d1*d1)/(w*w*0.018))*0.75;
        const b2=Math.max(0,1-(d2*d2)/(w*w*0.03))*0.45;
        cell.displayAlpha=Math.min(1,cell.alpha+b1+b2);
      }
    },
    // Canvas-based render: globalAlpha + one fillStyle per frame = fast
    drawFrame(ctx,s,dt,t){
      this.stepPhysics(s,dt,t);
      const {sz,grid,w,h}=s;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle=state.animColor||'#ffffff';
      ctx.textBaseline='top';
      ctx.font=`${sz-2}px ${state.fontFamily||"'Courier New',monospace"}`;
      for(let r=0;r<grid.length;r++) for(let c=0;c<grid[r].length;c++){
        const a=grid[r][c].displayAlpha;
        if(a<0.025) continue;
        ctx.globalAlpha=a;
        ctx.fillText(grid[r][c].char,c*sz,r*sz);
      }
      ctx.globalAlpha=1;
    },
    toSVGString(s){
      const {sz,grid,w,h}=s;
      const color=state.animColor||'#ffffff';
      const ff=state.fontFamily||"'Courier New',monospace";
      let out='';
      for(let r=0;r<grid.length;r++) for(let c=0;c<grid[r].length;c++){
        const cell=grid[r][c];
        const a=cell.displayAlpha||cell.alpha; if(a<0.025) continue;
        const ch=cell.char.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        out+=`<text x="${c*sz}" y="${r*sz+sz}" opacity="${a.toFixed(3)}">${ch}</text>`;
      }
      return `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg" style="font-family:${ff};font-size:${sz-2}px;fill:${color}">${out}</svg>`;
    },
    staticPreviewSVG(pw,ph){
      const s=this.createState(pw,ph);
      const fakeT=1000;
      for(let i=0;i<60;i++) this.stepPhysics(s,16,fakeT+i*16);
      return this.toSVGString(s);
    }
  },

  /* ── NOISE FIELD ─────────────────────────────────────────────── */
  'noise-field': {
    label:'Noise Field',
    createState(w,h){
      const sz=16, chars=getAnimGradient(state.charset);
      return {sz,w,h,chars,cols:Math.ceil(w/sz),rows:Math.ceil(h/sz),t:0};
    },
    stepPhysics(s,dt){s.t+=dt*0.00055;},
    drawFrame(ctx,s,dt){
      this.stepPhysics(s,dt);
      const {sz,chars,cols,rows,w,h,t:T}=s;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle=state.animColor||'#ffffff';
      ctx.textBaseline='top';
      ctx.font=`${sz}px ${state.fontFamily||"'Courier New',monospace"}`;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const nx=c/cols,ny=r/rows;
        const v=(
          Math.sin(nx*5.1+T)*Math.cos(ny*3.7-T*0.8)*0.5+
          Math.sin(nx*10.3-T*1.3)*Math.cos(ny*8.1+T*0.6)*0.25+
          Math.sin((nx+ny)*7.2+T*0.9)*0.15+
          Math.cos(nx*2.4-ny*4.8+T*0.4)*0.1+0.5);
        const cl=Math.max(0,Math.min(1,v));
        const idx=Math.floor(cl*(chars.length-1));
        if(idx<1) continue;
        ctx.globalAlpha=0.1+cl*0.85;
        ctx.fillText(chars[idx],c*sz,r*sz);
      }
      ctx.globalAlpha=1;
    },
    toSVGString(s){
      const {sz,chars,cols,rows,w,h,t:T}=s;
      const color=state.animColor||'#ffffff';
      const ff=state.fontFamily||"'Courier New',monospace";
      let out='';
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const nx=c/cols,ny=r/rows;
        const v=(Math.sin(nx*5.1+T)*Math.cos(ny*3.7-T*0.8)*0.5+Math.sin(nx*10.3-T*1.3)*Math.cos(ny*8.1+T*0.6)*0.25+Math.sin((nx+ny)*7.2+T*0.9)*0.15+Math.cos(nx*2.4-ny*4.8+T*0.4)*0.1+0.5);
        const cl=Math.max(0,Math.min(1,v));
        const idx=Math.floor(cl*(chars.length-1));
        if(idx<1) continue;
        out+=`<text x="${c*sz}" y="${r*sz+sz}" opacity="${(0.1+cl*0.85).toFixed(3)}">${chars[idx]}</text>`;
      }
      return `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg" style="font-family:${ff};font-size:${sz}px;fill:${color}">${out}</svg>`;
    },
    staticPreviewSVG(pw,ph){
      const s=this.createState(pw,ph);
      for(let i=0;i<60;i++) this.stepPhysics(s,16);
      return this.toSVGString(s);
    }
  }

};

function startAnimation(key){
  stopAnimation();
  animKey=key;
  const anim=ANIMATIONS[key];
  const W=svgContainer.clientWidth, H=svgContainer.clientHeight;
  // DPR-corrected canvas: crisp on Retina, capped at 2× to limit memory use
  const dpr=Math.min(window.devicePixelRatio||1, 2);
  animCanvas.width=W*dpr; animCanvas.height=H*dpr;
  animCanvas.style.width=W+'px'; animCanvas.style.height=H+'px';
  const ctx=animCanvas.getContext('2d');
  ctx.scale(dpr,dpr);
  animStateObj=anim.createState(W,H);
  svgWrapper.style.display='none';
  animCanvas.style.display='block';
  document.getElementById('outputWrap').classList.add('visible');
  document.getElementById('statusText').textContent=anim.label+' — Animation';
  animPrevT=0;
  let lastDrawT=0;
  const TARGET_MS=1000/24; // cap at 24 fps — 60% less CPU vs 60fps
  function loop(t){
    animRaf=requestAnimationFrame(loop);
    if(t-lastDrawT<TARGET_MS) return;
    const dt=animPrevT?Math.min(t-animPrevT,100):16;
    animPrevT=t; lastDrawT=t;
    anim.drawFrame(ctx,animStateObj,dt,t);
  }
  animRaf=requestAnimationFrame(loop);
}

function stopAnimation(){
  if(animRaf){cancelAnimationFrame(animRaf);animRaf=null;}
  animKey=null; animStateObj=null;
  animCanvas.style.display='none';
  svgWrapper.style.display='';
  const btn=document.getElementById('exportAnimJson');
  if(btn){btn.style.opacity='0.4';btn.style.pointerEvents='none';}
}

// ── Lottie export helpers ─────────────────────────────────────
function exportAnimLottie() {
  if (!animKey || !animStateObj) return;

  // ── Parameters ─────────────────────────────────────────────
  // Image-frame approach: render each frame to an offscreen canvas,
  // embed as base64 PNG assets (ty:2). Works in every Lottie player —
  // no font-embedding needed, no ty:5 text layer complexity.
  const fps = 8;
  const totalFrames = fps * 3;   // 24 frames = 3-second loop
  const dtMs = 1000 / fps;
  const exportW = 320, exportH = 224;
  const anim = ANIMATIONS[animKey];

  // Offscreen canvas for rendering
  const offCanvas = document.createElement('canvas');
  offCanvas.width = exportW; offCanvas.height = exportH;
  const ctx = offCanvas.getContext('2d');

  // Fresh state — doesn't disturb the live animation
  const s = anim.createState(exportW, exportH);

  // Warm up ~1s so cells aren't cold/empty
  for (let i = 0; i < 30; i++) {
    const t = (i + 1) * 33;
    animKey === 'symbol-tide' ? anim.stepPhysics(s, 33, t) : anim.stepPhysics(s, 33);
  }

  // ── Render frames ──────────────────────────────────────────
  const assets = [], layers = [];
  const bg = state.bgColor || '#000000';

  for (let f = 0; f < totalFrames; f++) {
    // Fill background, then draw animation frame
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, exportW, exportH);
    if (animKey === 'symbol-tide') {
      anim.drawFrame(ctx, s, dtMs, 1000 + f * dtMs);
    } else {
      anim.drawFrame(ctx, s, dtMs);
    }

    // Capture as base64 PNG (ASCII art compresses very well)
    // e:1 = embedded; lottie-web expects the full data URI in p, not just base64
    const id = `img_${f}`;
    const dataUrl = offCanvas.toDataURL('image/png');
    assets.push({id, w: exportW, h: exportH, u: '', p: dataUrl, e: 1});

    // Each image layer is visible for exactly 1 frame → slideshow loop
    layers.push({
      ddd: 0, ind: f + 1, ty: 2, nm: `f${f}`,
      refId: id, sr: 1,
      ks: {
        o: {a: 0, k: 100},
        r: {a: 0, k: 0},
        p: {a: 0, k: [exportW / 2, exportH / 2, 0]},
        a: {a: 0, k: [exportW / 2, exportH / 2, 0]},
        s: {a: 0, k: [100, 100, 100]}
      },
      ao: 0, ip: f, op: f + 1, st: 0, bm: 0
    });
  }

  // ── Root Lottie object ─────────────────────────────────────
  const lottie = {
    v: '5.5.7', fr: fps, ip: 0, op: totalFrames,
    w: exportW, h: exportH,
    nm: ANIMATIONS[animKey].label,
    ddd: 0, assets, layers
  };

  dlBlob(
    new Blob([JSON.stringify(lottie)], {type: 'application/json'}),
    `ascii-${animKey}.json`
  );
}

// Render static SVG previews into thumbnail <img> elements
function initAnimPreviews(){
  document.querySelectorAll('.lib-anim-thumb').forEach(thumb=>{
    const key=thumb.dataset.anim, anim=ANIMATIONS[key];
    if(!anim) return;
    const img=thumb.querySelector('.anim-preview-img');
    if(!img) return;
    const pw=thumb.offsetWidth||128, ph=Math.round(pw/1.6)||80;
    const svgStr=anim.staticPreviewSVG(pw,ph);
    const blob=new Blob([svgStr],{type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    img.onload=()=>URL.revokeObjectURL(url);
    img.src=url;
  });
}

// Update active animation's chars when charset changes
function updateAnimChars(){
  if(!animKey||!animStateObj) return;
  if(animKey==='symbol-tide'){
    animStateObj.chars=getAnimSymbols(state.charset);
    for(const row of animStateObj.grid) for(const cell of row) cell.changeAt=0;
  } else if(animKey==='noise-field'){
    animStateObj.chars=getAnimGradient(state.charset);
  }
}

// Library tabs
document.getElementById('libTabImages').addEventListener('click',()=>{
  document.getElementById('libTabImages').classList.add('active');
  document.getElementById('libTabAnims').classList.remove('active');
  document.getElementById('libImgGrid').classList.remove('hidden');
  document.getElementById('libAnimGrid').classList.add('hidden');
});
document.getElementById('libTabAnims').addEventListener('click',()=>{
  document.getElementById('libTabAnims').classList.add('active');
  document.getElementById('libTabImages').classList.remove('active');
  document.getElementById('libAnimGrid').classList.remove('hidden');
  document.getElementById('libImgGrid').classList.add('hidden');
  initAnimPreviews();
});

// Animation thumbnail clicks
document.querySelectorAll('.lib-anim-thumb').forEach(thumb=>{
  thumb.addEventListener('click',()=>{
    document.querySelectorAll('.lib-anim-thumb').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.lib-thumb').forEach(t=>t.classList.remove('active'));
    thumb.classList.add('active');
    startAnimation(thumb.dataset.anim);
    const btn=document.getElementById('exportAnimJson');
    btn.style.opacity='1'; btn.style.pointerEvents='auto';
  });
});

// Animation color picker
document.getElementById('animColorPicker').addEventListener('input',e=>{
  state.animColor=e.target.value;
});

// Export Lottie JSON
document.getElementById('exportAnimJson').addEventListener('click', exportAnimLottie);

// Image library
document.querySelectorAll('.lib-thumb').forEach(thumb=>{
  thumb.addEventListener('click',()=>{
    document.querySelectorAll('.lib-thumb').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.lib-anim-thumb').forEach(t=>t.classList.remove('active'));
    thumb.classList.add('active');
    stopAnimation();
    loadImageUrl(thumb.dataset.src, thumb.dataset.label);
  });
});

// Accordion sections
document.querySelectorAll('.section-hdr').forEach(hdr=>{
  hdr.addEventListener('click',()=>{
    const body=document.getElementById('body-'+hdr.dataset.section);
    hdr.classList.toggle('open');
    body.classList.toggle('hidden');
  });
});

// ═══════════════════════════════════════════════════════════════
//  MODE SWITCHING (ASCII ↔ DITHER)
// ═══════════════════════════════════════════════════════════════
let appMode = 'ascii';

function switchMode(mode) {
  appMode = mode;
  document.body.classList.toggle('dither-mode', mode === 'dither');
  document.getElementById('modeAscii').classList.toggle('active', mode === 'ascii');
  document.getElementById('modeDither').classList.toggle('active', mode === 'dither');
  if (mode === 'dither') {
    const noImg = document.getElementById('ditherNoImg');
    if (state.imageLoaded) { noImg.style.display = 'none'; scheduleDither(); }
    else { noImg.style.display = 'block'; }
  } else {
    document.getElementById('ditherCanvas').classList.remove('active');
    if (state.imageLoaded) scheduleRender();
  }
}

document.getElementById('modeAscii').addEventListener('click', () => switchMode('ascii'));
document.getElementById('modeDither').addEventListener('click', () => switchMode('dither'));
document.getElementById('ditherUploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());

// ═══════════════════════════════════════════════════════════════
//  DITHER STATE
// ═══════════════════════════════════════════════════════════════
const ditherState = {
  algo: 'floyd',
  dotSize: 2,
  threshold: 0,   // bias ±100 around midpoint 128
  contrast: 0,    // ±100
  invert: false,
  fg: '#1a1a1a',
  bg: '#b8c4e0'
};

let ditherDebounce = null;
function scheduleDither() {
  clearTimeout(ditherDebounce);
  ditherDebounce = setTimeout(runDither, 100);
}

// ═══════════════════════════════════════════════════════════════
//  DITHER ALGORITHMS
// ═══════════════════════════════════════════════════════════════
const BAYER4 = [
  [ 0,  8,  2, 10],
  [12,  4, 14,  6],
  [ 3, 11,  1,  9],
  [15,  7, 13,  5]
];
const BAYER8 = [
  [ 0, 32,  8, 40,  2, 34, 10, 42],
  [48, 16, 56, 24, 50, 18, 58, 26],
  [12, 44,  4, 36, 14, 46,  6, 38],
  [60, 28, 52, 20, 62, 30, 54, 22],
  [ 3, 35, 11, 43,  1, 33,  9, 41],
  [51, 19, 59, 27, 49, 17, 57, 25],
  [15, 47,  7, 39, 13, 45,  5, 37],
  [63, 31, 55, 23, 61, 29, 53, 21]
];

function dclamp(v) { return v < 0 ? 0 : v > 255 ? 255 : v; }

function errorDiffuse(gray, w, h, thr, spread) {
  const d = new Float32Array(gray);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const i = y * w + x;
      const old = dclamp(d[i]);
      const nw = old < thr ? 0 : 255;
      d[i] = nw;
      const err = old - nw;
      for (const [dx, dy, wt] of spread) {
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < w && ny >= 0 && ny < h) d[ny * w + nx] += err * wt;
      }
    }
  }
  return d;
}

const DITHER_ALGOS = {
  floyd:    (g,w,h,t) => errorDiffuse(g,w,h,t,[
    [1,0,7/16],[-1,1,3/16],[0,1,5/16],[1,1,1/16]]),
  atkinson: (g,w,h,t) => errorDiffuse(g,w,h,t,[
    [1,0,1/8],[2,0,1/8],[-1,1,1/8],[0,1,1/8],[1,1,1/8],[0,2,1/8]]),
  stucki:   (g,w,h,t) => errorDiffuse(g,w,h,t,[
    [1,0,8/42],[2,0,4/42],
    [-2,1,2/42],[-1,1,4/42],[0,1,8/42],[1,1,4/42],[2,1,2/42],
    [-2,2,1/42],[-1,2,2/42],[0,2,4/42],[1,2,2/42],[2,2,1/42]]),
  sierra:   (g,w,h,t) => errorDiffuse(g,w,h,t,[
    [1,0,5/32],[2,0,3/32],
    [-2,1,2/32],[-1,1,4/32],[0,1,5/32],[1,1,4/32],[2,1,2/32],
    [-1,2,2/32],[0,2,3/32],[1,2,2/32]]),
  bayer4: (g,w,h,t) => {
    const o = new Float32Array(w*h);
    for (let y=0;y<h;y++) for (let x=0;x<w;x++) {
      const b = (BAYER4[y%4][x%4]/16 - 0.5)*85;
      o[y*w+x] = dclamp(g[y*w+x]+b) < t ? 0 : 255;
    }
    return o;
  },
  bayer8: (g,w,h,t) => {
    const o = new Float32Array(w*h);
    for (let y=0;y<h;y++) for (let x=0;x<w;x++) {
      const b = (BAYER8[y%8][x%8]/64 - 0.5)*85;
      o[y*w+x] = dclamp(g[y*w+x]+b) < t ? 0 : 255;
    }
    return o;
  }
};

// ═══════════════════════════════════════════════════════════════
//  DITHER RENDER
// ═══════════════════════════════════════════════════════════════
function runDither() {
  if (!state.imageLoaded || appMode !== 'dither') return;
  const img = state.imageEl;
  const container = document.getElementById('svgContainer');
  const cw = container.clientWidth, ch = container.clientHeight;
  const ds = Math.max(1, ditherState.dotSize);

  // Fit image aspect ratio in container
  const imgAR = img.naturalWidth / img.naturalHeight;
  const conAR = cw / ch;
  let drawW, drawH;
  if (imgAR > conAR) { drawW = cw; drawH = Math.round(cw / imgAR); }
  else               { drawH = ch; drawW = Math.round(ch * imgAR); }

  // Working resolution: one cell per dot
  const workW = Math.max(1, Math.floor(drawW / ds));
  const workH = Math.max(1, Math.floor(drawH / ds));

  // Sample image at low resolution
  const tmp = document.createElement('canvas');
  tmp.width = workW; tmp.height = workH;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img, 0, 0, workW, workH);
  const px = tctx.getImageData(0, 0, workW, workH).data;

  // Grayscale + contrast adjustment
  const cf = ditherState.contrast !== 0
    ? (259 * (ditherState.contrast + 255)) / (255 * (259 - ditherState.contrast))
    : 1;
  const gray = new Float32Array(workW * workH);
  for (let i = 0; i < workW * workH; i++) {
    let lum = 0.299 * px[i*4] + 0.587 * px[i*4+1] + 0.114 * px[i*4+2];
    if (cf !== 1) lum = dclamp(cf * (lum - 128) + 128);
    gray[i] = ditherState.invert ? 255 - lum : lum;
  }

  // Run algorithm
  const thr = 128 + ditherState.threshold;
  const fn = DITHER_ALGOS[ditherState.algo] || DITHER_ALGOS.floyd;
  const dithered = fn(gray, workW, workH, thr);

  // Paint output canvas
  const outC = document.getElementById('ditherCanvas');
  outC.width = cw; outC.height = ch;
  const ctx = outC.getContext('2d');
  const [bgR,bgG,bgB] = hexToRgb(ditherState.bg);
  const [fgR,fgG,fgB] = hexToRgb(ditherState.fg);

  // Background fill
  ctx.fillStyle = ditherState.bg;
  ctx.fillRect(0, 0, cw, ch);

  // Center the dithered block
  const offX = Math.floor((cw - workW * ds) / 2);
  const offY = Math.floor((ch - workH * ds) / 2);

  // Build pixel-block ImageData
  const out = ctx.createImageData(workW * ds, workH * ds);
  const od = out.data;
  for (let y = 0; y < workH; y++) {
    for (let x = 0; x < workW; x++) {
      const dot = dithered[y * workW + x] === 0;
      const r = dot ? fgR : bgR, g = dot ? fgG : bgG, b = dot ? fgB : bgB;
      for (let dy = 0; dy < ds; dy++) {
        for (let dx = 0; dx < ds; dx++) {
          const oi = ((y*ds+dy) * (workW*ds) + (x*ds+dx)) * 4;
          od[oi]=r; od[oi+1]=g; od[oi+2]=b; od[oi+3]=255;
        }
      }
    }
  }
  ctx.putImageData(out, offX, offY);
  outC.classList.add('active');
}

// ── Dither exports ───────────────────────────────────────────
function exportDitherPng() {
  const c = document.getElementById('ditherCanvas');
  c.toBlob(b => dlBlob(b, 'dither.png'), 'image/png');
}
function exportDitherSvg() {
  if (!state.imageLoaded || appMode !== 'dither') return;
  const img = state.imageEl;
  const ds = Math.max(1, ditherState.dotSize);
  const imgAR = img.naturalWidth / img.naturalHeight;
  // Use a fixed export size for SVG
  const exportW = 1200, exportH = Math.round(1200 / imgAR);
  const workW = Math.max(1, Math.floor(exportW / ds));
  const workH = Math.max(1, Math.floor(exportH / ds));

  const tmp = document.createElement('canvas');
  tmp.width = workW; tmp.height = workH;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img, 0, 0, workW, workH);
  const px = tctx.getImageData(0, 0, workW, workH).data;
  const cf = ditherState.contrast !== 0
    ? (259*(ditherState.contrast+255))/(255*(259-ditherState.contrast)) : 1;
  const gray = new Float32Array(workW*workH);
  for (let i=0;i<workW*workH;i++) {
    let lum=0.299*px[i*4]+0.587*px[i*4+1]+0.114*px[i*4+2];
    if(cf!==1) lum=dclamp(cf*(lum-128)+128);
    gray[i]=ditherState.invert?255-lum:lum;
  }
  const thr=128+ditherState.threshold;
  const dithered=(DITHER_ALGOS[ditherState.algo]||DITHER_ALGOS.floyd)(gray,workW,workH,thr);

  let rects='';
  for (let y=0;y<workH;y++) for (let x=0;x<workW;x++) {
    if (dithered[y*workW+x]===0)
      rects+=`<rect x="${x*ds}" y="${y*ds}" width="${ds}" height="${ds}"/>`;
  }
  const svg=`<svg xmlns="http://www.w3.org/2000/svg" width="${exportW}" height="${exportH}" viewBox="0 0 ${exportW} ${exportH}"><rect width="${exportW}" height="${exportH}" fill="${ditherState.bg}"/><g fill="${ditherState.fg}">${rects}</g></svg>`;
  dlBlob(new Blob([svg],{type:'image/svg+xml'}), 'dither.svg');
}

document.getElementById('ditherExportPng').addEventListener('click', exportDitherPng);
document.getElementById('ditherExportSvg').addEventListener('click', exportDitherSvg);

// ── Dither control wiring ────────────────────────────────────
document.querySelectorAll('.algo-pill').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.algo-pill').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    ditherState.algo = btn.dataset.algo;
    scheduleDither();
  });
});

[
  ['dsize',    v => { ditherState.dotSize   = +v; document.getElementById('dsizeVal').textContent   = v+'px'; }],
  ['dthresh',  v => { ditherState.threshold = +v; document.getElementById('dthreshVal').textContent  = v; }],
  ['dcontrast',v => { ditherState.contrast  = +v; document.getElementById('dcontrastVal').textContent= v; }],
].forEach(([id, fn]) => {
  const el = document.getElementById(id);
  if (!el) return;
  updateSliderFill(el);
  el.addEventListener('input', e => { fn(e.target.value); updateSliderFill(e.target); scheduleDither(); });
});

document.getElementById('dinvert').addEventListener('click', () => {
  ditherState.invert = toggleEl('dinvert');
  scheduleDither();
});
document.getElementById('dfg').addEventListener('input', e => {
  ditherState.fg = e.target.value;
  e.target.closest('.color-swatch').style.background = e.target.value;
  scheduleDither();
});
document.getElementById('dbg').addEventListener('input', e => {
  ditherState.bg = e.target.value;
  e.target.closest('.color-swatch').style.background = e.target.value;
  scheduleDither();
});

// Resize: re-render dither when window resizes
window.addEventListener('resize', () => { if(appMode==='dither') scheduleDither(); });

// ═══════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════
// Init all slider fills
document.querySelectorAll('input[type=range]').forEach(updateSliderFill);
updateSliderFill(document.getElementById('scaleSlider'));
updateAllVals();

// Auto-load default image on start
setTimeout(()=>loadImageUrl('default.png','checkered-flag'), 200);
</script>
</body>
</html>
